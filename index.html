<!DOCTYPE html>

<html lang="en">
    <header style="background-color: #f0f0f0; padding: 10px; text-align: center;">
    <strong>Program Owner:</strong>
    <a href="https://researchonline.gcu.ac.uk/en/persons/ibrahim-k%C3%BC%C3%A7%C3%BCkdemiral" target="_blank" style="text-decoration: none; color: #007BFF;">
      Dr Ibrahim Küçükdemiral
    </a>
  </header>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.9">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  <style>
    .chart-container {
      width: 100%;
      height: 300px;
      margin: auto;
    }
    fieldset {
      margin-bottom: 1em;
    }
    label {
      margin-right: 0.5em;
    }
  </style>
  <title>Filtered PID Control Simulation</title>
</head>
<body>
  <h2>Filtered PID Controller Simulation for an Arbitrary Rational System</h2>
  <p>
    The system is modeled as a rational function:
    \[
      G(s)=\frac{N(s)}{D(s)}
    \]
    where you enter the numerator and denominator coefficients (in descending powers of \(s\)).
  </p>
  <p>
    The filtered PID controller is given by:
    \[
      u(s)=K_p\,e(s)+\frac{K_i}{s}\,e(s)+K_d\,\frac{N\,s}{s+N}\,e(s),
    \]
    where \(N\) is the derivative filter parameter and \(e(t)=\) Setpoint \(-\, y(t)\).
  </p>
  
  <form id="pidForm">
    <fieldset>
      <legend>System Transfer Function</legend>
      <label for="numerator">Numerator Coefficients:</label>
      <input type="text" id="numerator" size="30" value="0,2,3" placeholder="e.g. 0,2,3">
      <small>(For \(2s+3\) enter \(0,2,3\) to pad the missing \(s^2\) term.)</small><br/><br/>
      <label for="denominator">Denominator Coefficients:</label>
      <input type="text" id="denominator" size="30" value="1,4,5" placeholder="e.g. 1,4,5">
      <small>(For \(s^2+4s+5\) enter \(1,4,5\).)</small>
    </fieldset>
    
    <fieldset>
      <legend>PID Gains</legend>
      <label for="kp">Proportional (\(K_p\)):</label>
      <input type="number" step="0.1" id="kp" value="1">
      <label for="ki">Integral (\(K_i\)):</label>
      <input type="number" step="0.1" id="ki" value="0">
      <label for="kd">Derivative (\(K_d\)):</label>
      <input type="number" step="0.1" id="kd" value="0">
      <label for="N_filter">Derivative Filter (N):</label>
      <input type="number" step="0.1" id="N_filter" value="10">
    </fieldset>
    
    <fieldset>
      <legend>Simulation Settings</legend>
      <label for="duration">Duration (sec):</label>
      <input type="number" step="1" id="duration" value="10">
      <label for="dt">Time Step (sec):</label>
      <input type="number" step="0.001" id="dt" value="0.01">
      <label for="setpoint">Setpoint:</label>
      <input type="number" step="0.1" id="setpoint" value="1"><br/><br/>
      <label for="saturation">Symmetric saturation on \(u\):</label>
      <input type="number" step="0.1" id="saturation" value="1">
    </fieldset>
    
    <button type="button" onclick="simulate()">Run Simulation</button>
  </form>
  
  <div class="chart-container">
    <canvas id="outputPlot"></canvas>
  </div>
  <div class="chart-container">
    <canvas id="controlPlot"></canvas>
  </div>
  
  <script>
    let chartInstance1 = null;
    let chartInstance2 = null;
    
    // Helper: dot product of two arrays.
    function dotProduct(v1, v2) {
      let sum = 0;
      for (let i = 0; i < v1.length; i++) {
        sum += v1[i] * v2[i];
      }
      return sum;
    }
    
    // Multiply matrix A (2D array) by vector x.
    function multiplyMatrixVector(A, x) {
      let result = [];
      for (let i = 0; i < A.length; i++) {
        let sum = 0;
        for (let j = 0; j < x.length; j++) {
          sum += A[i][j] * x[j];
        }
        result.push(sum);
      }
      return result;
    }
    
    function simulate() {
      // --- Get system (transfer function) coefficients ---
      let numStr = document.getElementById("numerator").value;
      let denStr = document.getElementById("denominator").value;
      
      // Parse coefficients (expect comma–separated numbers)
      let numCoeffs = numStr.split(",").map(s => parseFloat(s.trim()));
      let denCoeffs = denStr.split(",").map(s => parseFloat(s.trim()));
      
      if (denCoeffs.length < 1 || isNaN(denCoeffs[0]) || denCoeffs[0] === 0) {
        alert("Invalid denominator. The first coefficient must be nonzero.");
        return;
      }
      
      // Normalize so that the highest–order coefficient of the denominator is 1.
      let lead = denCoeffs[0];
      denCoeffs = denCoeffs.map(c => c / lead);
      numCoeffs = numCoeffs.map(c => c / lead);
      
      // Let n = degree of denominator, m = degree of numerator.
      let n = denCoeffs.length - 1;
      let m = numCoeffs.length - 1;
      if (m > n) {
        alert("The numerator degree must be less than or equal to the denominator degree.");
        return;
      }
      
      // If numerator degree is lower than denominator degree, pad with zeros at the front.
      while (numCoeffs.length < denCoeffs.length) {
        numCoeffs.unshift(0);
      }
      // Now both arrays have length n+1.
      // In controllable canonical form for a transfer function written as:
      //   G(s) = (b0 s^n + b1 s^(n-1) + ... + b_n) / (s^n + a1 s^(n-1) + ... + a_n)
      // we choose:
      //   D_value = b0
      //   C = [b1 - a1*D_value, b2 - a2*D_value, ..., b_n - a_n*D_value]
      //   A = companion matrix built from -a1, -a2, ..., -a_n.
      //   B = [1, 0, ..., 0]^T
      let D_value = numCoeffs[0];
      let C = [];
      for (let i = 0; i < n; i++) {
        C.push(numCoeffs[i + 1] - denCoeffs[i + 1] * D_value);
      }
      
      // Build companion matrix A (n x n)
      let A = [];
      for (let i = 0; i < n; i++) {
        A[i] = [];
        for (let j = 0; j < n; j++) {
          if (i === 0) {
            // First row: negative of the denominator coefficients (skipping the leading one)
            A[i][j] = -denCoeffs[j + 1];
          } else {
            // Subdiagonal ones.
            A[i][j] = (j === i - 1) ? 1 : 0;
          }
        }
      }
      
      // B vector is [1, 0, ..., 0]
      let B = new Array(n).fill(0);
      if (n > 0) {
        B[0] = 1;
      }
      
      // --- Get PID and simulation parameters ---
      const Kp = parseFloat(document.getElementById("kp").value);
      const Ki = parseFloat(document.getElementById("ki").value);
      const Kd = parseFloat(document.getElementById("kd").value);
      const N_filter = parseFloat(document.getElementById("N_filter").value);
      const duration = parseFloat(document.getElementById("duration").value);
      const dt = parseFloat(document.getElementById("dt").value);
      const setpoint = parseFloat(document.getElementById("setpoint").value);
      const saturation = parseFloat(document.getElementById("saturation").value);
      
      // Arrays to store simulation data
      const timeArr = [];
      const outputArr = [];
      const controlArr = [];
      
      // Initial conditions:
      let t = 0;
      // State vector x (for n > 0; for n = 0 we have a static gain system: y = D_value*u).
      let x = (n > 0) ? new Array(n).fill(0) : [];
      let u = 0;
      
      // Compute initial output: if n > 0 then y = C*x + D_value*u, else y = D_value*u.
      let y = (n > 0) ? dotProduct(C, x) + D_value * u : D_value * u;
      let error = setpoint - y;
      let integral = 0;
      let previousError = error;
      // d_term is the state for the filtered derivative term.
      let d_term = 0;
      
      // Run the simulation loop.
      while (t <= duration) {
        // Record current time and output.
        timeArr.push(t.toFixed(2));
        outputArr.push(y);
        
        // Compute error.
        error = setpoint - y;
        
        // Integral term.
        integral += error * dt;
        
        // Filtered derivative update:
        // Using Euler integration on:  d_dot + N_filter*d = Kd*N_filter*e_dot,
        // where e_dot is approximated by (error - previousError)/dt.
        d_term = (1 - N_filter * dt) * d_term + Kd * N_filter * (error - previousError);
        
        // Compute controller output.
        let u_new = Kp * error + Ki * integral + d_term;
        // Apply symmetric saturation.
        u_new = Math.max(-saturation, Math.min(saturation, u_new));
        controlArr.push(u_new);
        
        // Update the system state (Euler integration of state–space model).
        if (n > 0) {
          let Ax = multiplyMatrixVector(A, x);
          let x_new = [];
          for (let i = 0; i < n; i++) {
            x_new.push(x[i] + dt * (Ax[i] + B[i] * u_new));
          }
          x = x_new;
          // Compute output: y = C*x + D_value*u_new.
          y = dotProduct(C, x) + D_value * u_new;
        } else {
          // For a zero–order system, y = D_value*u.
          y = D_value * u_new;
        }
        
        previousError = error;
        u = u_new;
        t += dt;
      }
      
      plotData(timeArr, outputArr, setpoint, controlArr, saturation);
    }
    
    function plotData(timeArr, outputArr, setpoint, controlArr, saturation) {
      const ctx1 = document.getElementById("outputPlot").getContext("2d");
      const ctx2 = document.getElementById("controlPlot").getContext("2d");
      
      if (chartInstance1) chartInstance1.destroy();
      if (chartInstance2) chartInstance2.destroy();
      
      // Plot for the System Response (Output)
      chartInstance1 = new Chart(ctx1, {
        type: 'line',
        data: {
          labels: timeArr,
          datasets: [{
            label: 'System Response',
            data: outputArr,
            borderColor: 'blue',
            fill: false,
          }, {
            label: 'Setpoint',
            data: Array(timeArr.length).fill(setpoint),
            borderColor: 'red',
            borderDash: [3, 3],
            fill: false,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            x: { title: { display: true, text: 'Time (s)' } },
            y: { title: { display: true, text: 'Output' } }
          }
        }
      });
      
      // Plot for the Control Signal with saturation limits.
      chartInstance2 = new Chart(ctx2, {
        type: 'line',
        data: {
          labels: timeArr,
          datasets: [{
            label: 'Control Signal (u)',
            data: controlArr,
            borderColor: 'green',
            fill: false,
          }, {
            label: 'Saturation Upper Limit',
            data: Array(timeArr.length).fill(saturation),
            borderColor: 'black',
            borderDash: [3, 3],
            fill: false,
          }, {
            label: 'Saturation Lower Limit',
            data: Array(timeArr.length).fill(-saturation),
            borderColor: 'black',
            borderDash: [3, 3],
            fill: false,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            x: { title: { display: true, text: 'Time (s)' } },
            y: { title: { display: true, text: 'Control Signal' } }
          }
        }
      });
    }
  </script>
</body>
</html>
