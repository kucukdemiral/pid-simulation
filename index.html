<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PID with State-Space</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
<form>
    <!-- Numerator/Denominator, e.g. num=1,0,2  den=1,3,2 -->
    Numerator: <input type="text" id="num" value="1,0,2">
    Denominator: <input type="text" id="den" value="1,3,2"><br/>
    Kp: <input type="number" step="0.1" id="kp" value="1">
    Ki: <input type="number" step="0.1" id="ki" value="0">
    Kd: <input type="number" step="0.1" id="kd" value="0"><br/>
    Duration (sec): <input type="number" step="1" id="duration" value="10">
    Time Step: <input type="number" step="0.001" id="dt" value="0.01"><br/>
    Setpoint: <input type="number" step="0.1" id="setpoint" value="1">
    Saturation: <input type="number" step="0.1" id="sat" value="1">
    <button type="button" onclick="simulate()">Run</button>
</form>

<canvas id="resp" width="500" height="200"></canvas>
<canvas id="ctrl" width="500" height="200"></canvas>

<script>
function simulate() {
    // 1) Parse inputs
    const num = document.getElementById('num').value.split(',').map(Number);
    const den = document.getElementById('den').value.split(',').map(Number);
    const Kp = parseFloat(document.getElementById('kp').value);
    const Ki = parseFloat(document.getElementById('ki').value);
    const Kd = parseFloat(document.getElementById('kd').value);
    const duration = parseFloat(document.getElementById('duration').value);
    const dt = parseFloat(document.getElementById('dt').value);
    const setpoint = parseFloat(document.getElementById('setpoint').value);
    const sat = parseFloat(document.getElementById('sat').value);

    // 2) Convert to controllable canonical form
    const {A, B, C, D} = tf2ss(num, den);

    // States for n-th order system
    const n = A.length;         // System order
    let x = new Array(n).fill(0);

    // PID variables
    let integral = 0;
    let prevError = setpoint;   // error(t-dt)
    
    // Storage for plotting
    const tVals = [];
    const yVals = [];
    const uVals = [];

    for (let t=0; t<=duration; t+=dt) {
        tVals.push(t);

        // Output of the system
        const y = matDot(C, x) /* y= C x */ + D*0; // If there's a direct feedthrough, + D*u (not used here by default)
        yVals.push(y);

        // Compute the PID
        const error = setpoint - y;
        integral += error * dt;
        const deriv = (error - prevError)/dt;
        let u = Kp*error + Ki*integral + Kd*deriv;
        // Saturation
        u = Math.max(-sat, Math.min(sat, u));
        uVals.push(u);

        // State-Space Forward Euler: x(k+1) = x(k) + dt*(A x(k) + B u(k))
        const Ax = matVecMul(A, x);
        for(let i=0; i<n; i++){
            // A x + B u
            Ax[i] += B[i]*u;
        }
        // x <-- x + dt*(Ax + B u)
        for(let i=0; i<n; i++){
            x[i] += dt*Ax[i];
        }

        prevError = error;
    }

    plotResults(tVals, yVals, uVals);
}

// Helper: Convert TF -> State-Space in Controllable Canonical Form
function tf2ss(num, den) {
    // Make sure leading den coeff is 1
    const a0 = den[0];
    if (a0 !== 1) {
        for(let i=0; i<den.length; i++) den[i] /= a0;
        for(let i=0; i<num.length; i++) num[i] /= a0;
    }
    // System order
    const n = den.length - 1; 
    // Pad numerator if needed
    const m = num.length - 1; 
    // If numerator is lower order, pad with zeros
    if(m < n){
        const extra = n - m;
        for(let i=0; i<extra; i++){
            num.unshift(0);
        }
    }
    // A = [0 1 0 ... 0
    //      0 0 1 ... 0
    //      ...
    //     -an ...   -a1 ]
    const A = [];
    for(let i=0; i<n; i++){
        A.push(new Array(n).fill(0));
    }
    // Fill subdiagonal
    for(let i=0; i<n-1; i++){
        A[i][i+1] = 1;
    }
    // Last row from den
    // den = [1, a1, a2, ..., a_n]
    // A[n-1] = [-a_n, -a_{n-1}, ..., -a_1]
    for(let i=0; i<n; i++){
        A[n-1][i] = -den[n - i];
    }

    // B = [0, 0, ..., 1]^T
    const B = new Array(n).fill(0);
    B[n-1] = 1;

    // C, D from numerator
    // If we have n = denominator order, then we want C = [ (b_n - sum?), (b_{n-1} - ... ), ... ] etc
    // But in controllable canonical form:
    //  y = c1 x1 + c2 x2 + ... + c_n x_n + D u
    // The direct approach is:
    //   b(s)/a(s) = c*(sI - A)^(-1)*B + D
    // Usually, the standard formula is:
    //   C = [ (num[n-1] - num[n] * a_{1}), (num[n-2] - num[n] * a_{2}), ... ] 
    // but let's do a simpler approach: 
    //   c[i] = num[n - i] - a1 * ...
    // It's easier to do something standard like MATLAB's `tf2ss`. 
    // We'll do a basic approach for "direct" form of canonical structure:
    const C = new Array(n).fill(0);
    for(let i=0; i<n; i++){
        C[i] = num[n - 1 - i]; // reversed order
    }
    // If the polynomial orders are the same, there's a possible feedthrough term
    let D = 0;
    if(m === n){
        D = num[n] - 0; // The last coefficient 
    }
    return { A, B, C, D };
}

// Matrix-Vector multiply
function matVecMul(M, v){
    const r = new Array(M.length).fill(0);
    for(let i=0; i<M.length; i++){
        let sum = 0;
        for(let j=0; j<M[0].length; j++){
            sum += M[i][j] * v[j];
        }
        r[i] = sum;
    }
    return r;
}

// Dot product C x
function matDot(C, x){
    let sum = 0;
    for(let i=0; i<C.length; i++){
        sum += C[i]*x[i];
    }
    return sum;
}

function plotResults(time, output, control) {
    // Plot in two separate charts
    const ctx1 = document.getElementById('resp').getContext('2d');
    const ctx2 = document.getElementById('ctrl').getContext('2d');

    new Chart(ctx1, {
        type: 'line',
        data: {
            labels: time,
            datasets: [
                { label: 'Output y(t)', data: output, borderColor: 'blue', fill: false },
            ]
        },
        options: { responsive: true, maintainAspectRatio: false }
    });

    new Chart(ctx2, {
        type: 'line',
        data: {
            labels: time,
            datasets: [
                { label: 'Control u(t)', data: control, borderColor: 'green', fill: false },
            ]
        },
        options: { responsive: true, maintainAspectRatio: false }
    });
}
</script>
</body>
</html>
