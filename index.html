<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Chart.js, polyfill, and MathJax -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  <style>
    .chart-container {
      width: 100%;
      height: 300px;
      margin: auto;
    }
    fieldset {
      margin-bottom: 1em;
      padding: 10px;
      background-color: #f9f9f9; /* Light background */
      border: 2px solid #ccc;
    }
    label {
      margin-right: 0.5em;
    }
    input[type="text"] {
      width: 10em;
    }
    input[type="number"] {
      width: 5em;
    }
    /* Optional: Style the saturation toggle (checkbox) container */
    .toggle-container {
      display: inline-block;
      vertical-align: middle;
      margin-left: 5px;
    }
  </style>
  <title>Filtered PID Control Simulation with Delay</title>
</head>
<body>
  <h2>Filtered PID Controller Simulation for an Arbitrary Rational System with Delay</h2>
  <strong>Program Owner:</strong>
    <a href="https://researchonline.gcu.ac.uk/en/persons/ibrahim-k%C3%BC%C3%A7%C3%BCkdemiral" target="_blank" style="text-decoration: none; color: #007BFF;">
      Ibrahim Küçükdemiral
    </a>
  <p>
    The system is modeled as a rational function with delay:
    <br>
    \( G(s)=\dfrac{Y(s)}{U(s)}=\dfrac{N(s)}{D(s)}e^{-\tau s} \)
    <br>
    where you enter the numerator and denominator coefficients (in descending powers of \(s\)) and the delay \(\tau\).
  </p>
  <p>
    The filtered PID controller is given by:
    <br>
    \( U(s)=K_p\,E(s)+\dfrac{K_i}{s}\,E(s)+K_d\,\dfrac{F\,s}{s+F}\,E(s) \)
    <br>
    where \(F\) is the derivative filter parameter and \(e(t)=\mathrm{Setpoint}\,-\,y(t)\).
  </p>
  
  <form id="pidForm">
    <fieldset>
      <legend><strong>System Transfer Function</strong></legend>
      <label for="numerator">Numerator Coefficients:</label>
      <input type="text" id="numerator" size="10" value="2,3" placeholder="e.g. 2,3">
      <small>(For instance, for \(2s+3\) enter \(2,3\))</small><br/><br/>
      <label for="denominator">Denominator Coefficients:</label>
      <input type="text" id="denominator" size="10" value="1,0,5" placeholder="e.g. 1,0,5">
      <small>(For \(s^2+5\) enter \(1,0,5\).)</small><br/><br/>
      <label for="delay">Delay (τ in sec):</label>
      <input type="number" step="0.001" id="delay" value="0">
    </fieldset>
    
    <fieldset>
      <legend><strong>PID Gains</strong></legend>
      <label for="kp">Proportional (\(K_p\)):</label>
      <input type="number" step="0.1" id="kp" value="1">
      <label for="ki">Integral (\(K_i\)):</label>
      <input type="number" step="0.1" id="ki" value="0">
      <label for="kd">Derivative (\(K_d\)):</label>
      <input type="number" step="0.1" id="kd" value="0">
      <label for="N_filter">Derivative Filter (\(F\)):</label>
      <input type="number" step="1" id="N_filter" value="10">
    </fieldset>
    
    <fieldset>
      <legend><strong>Simulation Settings</strong></legend>
      <label for="duration">Duration (sec):</label>
      <input type="number" step="1" id="duration" value="10">
      <label for="dt">Time Step (sec):</label>
      <input type="number" step="0.001" id="dt" value="0.01">
      <label for="setpoint">Setpoint:</label>
      <input type="number" step="0.1" id="setpoint" value="1"><br/><br/>
      <!-- Non-symmetric saturation inputs -->
      <label for="u_max">\(u_{max}\):</label>
      <input type="number" step="0.1" id="u_max" value="1">
      <label for="u_min">\(u_{min}\):</label>
      <input type="number" step="0.1" id="u_min" value="-1">
      <!-- Saturation Toggle -->
      <label for="saturationToggle">Saturation:</label>
      <div class="toggle-container">
        <input type="checkbox" id="saturationToggle" checked>
      </div>
    </fieldset>
    
    <button type="button" onclick="simulate()">Run Simulation</button>
  </form>
  
  <div class="chart-container">
    <canvas id="outputPlot"></canvas>
  </div>
  <div class="chart-container">
    <canvas id="controlPlot"></canvas>
  </div>
  
  <script>
    let chartInstance1 = null;
    let chartInstance2 = null;
    
    // Helper: dot product of two arrays.
    function dotProduct(v1, v2) {
      let sum = 0;
      for (let i = 0; i < v1.length; i++) {
        sum += v1[i] * v2[i];
      }
      return sum;
    }
    
    // Helper: Multiply matrix A (2D array) by vector x.
    function multiplyMatrixVector(A, x) {
      let result = [];
      for (let i = 0; i < A.length; i++) {
        let sum = 0;
        for (let j = 0; j < x.length; j++) {
          sum += A[i][j] * x[j];
        }
        result.push(sum);
      }
      return result;
    }
    
    function simulate() {
      // --- Get system (transfer function) coefficients ---
      let numStr = document.getElementById("numerator").value;
      let denStr = document.getElementById("denominator").value;
      
      // Parse coefficients (expect comma-separated numbers)
      let numCoeffs = numStr.split(",").map(s => parseFloat(s.trim()));
      let denCoeffs = denStr.split(",").map(s => parseFloat(s.trim()));
      
      if (denCoeffs.length < 1 || isNaN(denCoeffs[0]) || denCoeffs[0] === 0) {
        alert("Invalid denominator. The first coefficient must be nonzero.");
        return;
      }
      
      // Normalize so that the highest–order coefficient of the denominator is 1.
      let lead = denCoeffs[0];
      denCoeffs = denCoeffs.map(c => c / lead);
      numCoeffs = numCoeffs.map(c => c / lead);
      
      // Let n = degree of denominator, m = degree of numerator.
      let n = denCoeffs.length - 1;
      let m = numCoeffs.length - 1;
      if (m > n) {
        alert("The numerator degree must be less than or equal to the denominator degree.");
        return;
      }
      
      // If numerator degree is lower than denominator degree, pad with zeros at the front.
      while (numCoeffs.length < denCoeffs.length) {
        numCoeffs.unshift(0);
      }
      
      // --- Construct state-space model (Controllable Canonical Form) ---
      // Direct feed-through term.
      let D_value = numCoeffs[0];
      let C = [];
      for (let i = 0; i < n; i++) {
        C.push(numCoeffs[i + 1] - denCoeffs[i + 1] * D_value);
      }
      
      // Build companion matrix A (n x n)
      let A = [];
      for (let i = 0; i < n; i++) {
        A[i] = [];
        for (let j = 0; j < n; j++) {
          if (i === 0) {
            A[i][j] = -denCoeffs[j + 1];
          } else {
            A[i][j] = (j === i - 1) ? 1 : 0;
          }
        }
      }
      
      // B vector is [1, 0, ..., 0]
      let B = new Array(n).fill(0);
      if (n > 0) {
        B[0] = 1;
      }
      
      // --- Get PID and simulation parameters ---
      const Kp = parseFloat(document.getElementById("kp").value);
      const Ki = parseFloat(document.getElementById("ki").value);
      const Kd = parseFloat(document.getElementById("kd").value);
      const N_filter = parseFloat(document.getElementById("N_filter").value);
      const duration = parseFloat(document.getElementById("duration").value);
      const dt = parseFloat(document.getElementById("dt").value);
      const setpoint = parseFloat(document.getElementById("setpoint").value);
      const u_max = parseFloat(document.getElementById("u_max").value);
      const u_min = parseFloat(document.getElementById("u_min").value);
      const tau = parseFloat(document.getElementById("delay").value);
      
      // Read the saturation toggle state.
      const saturationEnabled = document.getElementById("saturationToggle").checked;
      
      // Compute the number of delay steps (tau seconds corresponds to tau/dt steps)
      let delaySteps = Math.floor(tau / dt);
      // Initialize the delay buffer with zeros (initial control input is assumed 0)
      let delayBuffer = [];
      for (let i = 0; i < delaySteps; i++) {
        delayBuffer.push(0);
      }
      
      // Arrays to store simulation data
      const timeArr = [];
      const outputArr = [];
      const controlArr = [];
      
      // Initial conditions:
      let t = 0;
      let x = (n > 0) ? new Array(n).fill(0) : [];
      let u = 0;
      let y = (n > 0) ? dotProduct(C, x) + D_value * u : D_value * u;
      let error = setpoint - y;
      let integral = 0;
      let previousError = error;
      let d_term = 0;
      
      // --- Simulation Loop (using Trapezoidal Integration) ---
      while (t <= duration) {
        // Record current time and output.
        timeArr.push(t.toFixed(2));
        outputArr.push(y);
        
        // Compute current error.
        error = setpoint - y;
        
        // Trapezoidal integration for the error integral:
        integral += (error + previousError) * dt / 2;
        
        // Tustin’s method for the derivative filter.
        let alpha = (2 - N_filter * dt) / (2 + N_filter * dt);
        d_term = alpha * d_term + (2 * Kd * N_filter / (2 + N_filter * dt)) * (error - previousError);
        
        // Compute controller output.
        let u_new = Kp * error + Ki * integral + d_term;
        // Apply saturation if enabled.
        if (saturationEnabled) {
          u_new = Math.min(u_max, Math.max(u_min, u_new));
        }
        
        // --- Handle the delay ---
        // Push the current controller output into the delay buffer.
        delayBuffer.push(u_new);
        // Retrieve the delayed control input (u_delayed).
        let u_delayed = delayBuffer.shift();
        // Record the effective control input for plotting.
        controlArr.push(u_delayed);
        
        // Trapezoidal integration for the state update using the delayed control:
        if (n > 0) {
          let Ax = multiplyMatrixVector(A, x);
          // Predictor step: Euler prediction for the next state.
          let x_predict = [];
          for (let i = 0; i < n; i++) {
            x_predict[i] = x[i] + dt * (Ax[i] + B[i] * u_delayed);
          }
          // Compute derivative at the predicted state.
          let Ax_predict = multiplyMatrixVector(A, x_predict);
          // Corrector: average the derivatives.
          let x_new = [];
          for (let i = 0; i < n; i++) {
            x_new[i] = x[i] + (dt / 2) * ((Ax[i] + B[i] * u_delayed) + (Ax_predict[i] + B[i] * u_delayed));
          }
          x = x_new;
          y = dotProduct(C, x) + D_value * u_delayed;
        } else {
          y = D_value * u_delayed;
        }
        
        previousError = error;
        u = u_new;  // current controller output (not the delayed one)
        t += dt;
      }
      
      // Pass the saturation toggle state to the plotting function.
      plotData(timeArr, outputArr, setpoint, controlArr, u_max, u_min, saturationEnabled);
    }
    
    function plotData(timeArr, outputArr, setpoint, controlArr, u_max, u_min, saturationEnabled) {
      const ctx1 = document.getElementById("outputPlot").getContext("2d");
      const ctx2 = document.getElementById("controlPlot").getContext("2d");
      
      if (chartInstance1) chartInstance1.destroy();
      if (chartInstance2) chartInstance2.destroy();
      
      // Plot for the System Response (Output)
      chartInstance1 = new Chart(ctx1, {
        type: 'line',
        data: {
          labels: timeArr,
          datasets: [{
            label: 'System Response',
            data: outputArr,
            borderColor: 'blue',
            borderWidth: 1.5,
            pointRadius: 0,
            fill: false,
          }, {
            label: 'Setpoint',
            data: Array(timeArr.length).fill(setpoint),
            borderColor: 'red',
            borderWidth: 1,
            pointRadius: 0,
            borderDash: [5, 5],
            fill: false,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            x: { title: { display: true, text: 'Time \(t\)(s)' } },
            y: { title: { display: true, text: 'Output \(y(t)\)' } }
          }
        }
      });
      
      // Prepare datasets for the Control Signal plot.
      const controlDatasets = [{
        label: 'Control Signal (Delayed u)',
        data: controlArr,
        borderColor: 'green',
        borderWidth: 1.5,
        pointRadius: 0,
        fill: false,
      }];
      
      // If saturation is enabled, add saturation limit lines.
      if (saturationEnabled) {
        controlDatasets.push({
          label: 'Saturation Upper Limit',
          data: Array(timeArr.length).fill(u_max),
          borderColor: 'black',
          borderWidth: 1,
          pointRadius: 0,
          borderDash: [5, 5],
          fill: false,
        });
        controlDatasets.push({
          label: 'Saturation Lower Limit',
          data: Array(timeArr.length).fill(u_min),
          borderColor: 'black',
          borderWidth: 1,
          pointRadius: 0,
          borderDash: [5, 5],
          fill: false,
        });
      }
      
      chartInstance2 = new Chart(ctx2, {
        type: 'line',
        data: {
          labels: timeArr,
          datasets: controlDatasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            x: { title: { display: true, text: 'Time \(t\) (s)' } },
            y: { title: { display: true, text: 'Control Signal \(u(t)\)' } }
          }
        }
      });
    }
  </script>
</body>
</html>
