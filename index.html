<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.9">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  <style>
    .chart-container {
      width: 100%;
      height: 300px;
      margin: auto;
    }
    fieldset {
      margin-bottom: 1em;
    }
    label {
      margin-right: 0.5em;
    }
  </style>
  <title>Filtered PID Control Simulation</title>
</head>
<body>
  <h2>Filtered PID Controller Simulation for an Arbitrary Rational System</h2>
  <strong>Program Owner:</strong>
    <a href="https://researchonline.gcu.ac.uk/en/persons/ibrahim-k%C3%BC%C3%A7%C3%BCkdemiral" target="_blank" style="text-decoration: none; color: #007BFF;">
      Ibrahim Küçükdemiral
    </a>
  <p>
    The system is modeled as a rational function:
    $$ G(s)=\frac{N(s)}{D(s)} $$
    where you enter the numerator and denominator coefficients (in descending powers of \(s\)).
  </p>
  <p>
    The filtered PID controller is given by:
    $$ u(s)=K_p\,e(s)+\frac{K_i}{s}\,e(s)+K_d\,\frac{N\,s}{s+N}\,e(s), $$
    where \(N\) is the derivative filter parameter and \(e(t)=\) Reference \(-\, y(t)\).
  </p>
  
  <form id="pidForm">
    <fieldset>
      <legend>System Transfer Function</legend>
      <label for="numerator">Numerator Coefficients:</label>
      <input type="text" id="numerator" size="30" value="2,3" placeholder="e.g. 2,3">
      <small>(For example, for \(2s+3\) enter \(2,3\))</small><br/><br/>
      <label for="denominator">Denominator Coefficients:</label>
      <input type="text" id="denominator" size="30" value="1,0,5" placeholder="e.g. 1,0,5">
      <small>(For \(s^2+5\) enter \(1,0,5\))</small>
    </fieldset>
    
    <fieldset>
      <legend>PID Gains</legend>
      <label for="kp">Proportional (\(K_p\)):</label>
      <input type="number" step="0.1" id="kp" value="1">
      <label for="ki">Integral (\(K_i\)):</label>
      <input type="number" step="0.1" id="ki" value="0">
      <label for="kd">Derivative (\(K_d\)):</label>
      <input type="number" step="0.1" id="kd" value="0">
      <label for="N_filter">Derivative Filter (N):</label>
      <input type="number" step="0.1" id="N_filter" value="10">
    </fieldset>
    
    <fieldset>
      <legend>Simulation Settings</legend>
      <label for="duration">Duration (sec):</label>
      <input type="number" step="1" id="duration" value="10">
      <label for="dt">Time Step (sec):</label>
      <input type="number" step="0.001" id="dt" value="0.01"><br/><br/>
      <!-- Non-symmetric saturation inputs -->
      <label for="u_max">\(u_{max}\):</label>
      <input type="number" step="0.1" id="u_max" value="1">
      <label for="u_min">\(u_{min}\):</label>
      <input type="number" step="0.1" id="u_min" value="-1">
    </fieldset>

    <fieldset>
      <legend>Reference Signal</legend>
      <label for="refType">Reference Type:</label>
      <select id="refType">
        <option value="constant" selected>Constant</option>
        <option value="piecewise">Piecewise Linear</option>
        <option value="custom">Custom Function</option>
      </select><br/><br/>
      
      <div id="refConstant" class="refOption">
        <label for="setpoint">Setpoint:</label>
        <input type="number" step="0.1" id="setpoint" value="1">
      </div>
      
      <div id="refPiecewise" class="refOption" style="display:none;">
        <label for="refPiecewiseInput">Piecewise Reference (time:value pairs, e.g. "0:1, 5:2, 10:0"):</label>
        <input type="text" id="refPiecewiseInput" size="50" placeholder='0:1, 5:2, 10:0'>
      </div>
      
      <div id="refCustom" class="refOption" style="display:none;">
        <label for="refCustomInput">Custom Reference Function f(t):</label>
        <input type="text" id="refCustomInput" size="50" placeholder='e.g., t < 5 ? 1 : 2'>
        <small>Enter a JavaScript expression using "t".</small>
      </div>
    </fieldset>
    
    <button type="button" onclick="simulate()">Run Simulation</button>
  </form>
  
  <div class="chart-container">
    <canvas id="outputPlot"></canvas>
  </div>
  <div class="chart-container">
    <canvas id="controlPlot"></canvas>
  </div>
  
  <script>
    let chartInstance1 = null;
    let chartInstance2 = null;
    
    // Update the displayed reference input based on the chosen type.
    document.getElementById("refType").addEventListener("change", function() {
      const refType = this.value;
      document.getElementById("refConstant").style.display = (refType === "constant") ? "block" : "none";
      document.getElementById("refPiecewise").style.display = (refType === "piecewise") ? "block" : "none";
      document.getElementById("refCustom").style.display = (refType === "custom") ? "block" : "none";
    });
    
    // Helper: dot product of two arrays.
    function dotProduct(v1, v2) {
      let sum = 0;
      for (let i = 0; i < v1.length; i++) {
        sum += v1[i] * v2[i];
      }
      return sum;
    }
    
    // Multiply a matrix (2D array) A by a vector x.
    function multiplyMatrixVector(A, x) {
      let result = [];
      for (let i = 0; i < A.length; i++) {
        let sum = 0;
        for (let j = 0; j < x.length; j++) {
          sum += A[i][j] * x[j];
        }
        result.push(sum);
      }
      return result;
    }
    
    // Compute the reference (setpoint) at time t.
    function getReference(t) {
      const refType = document.getElementById("refType").value;
      if (refType === "constant") {
        return parseFloat(document.getElementById("setpoint").value);
      } else if (refType === "piecewise") {
        const input = document.getElementById("refPiecewiseInput").value;
        // Parse input such as "0:1, 5:2, 10:0"
        const pairs = input.split(",").map(s => s.trim()).filter(s => s !== "");
        let points = [];
        pairs.forEach(pair => {
          let parts = pair.split(":").map(s => s.trim());
          if (parts.length === 2) {
            let tVal = parseFloat(parts[0]);
            let yVal = parseFloat(parts[1]);
            if (!isNaN(tVal) && !isNaN(yVal)) {
              points.push({ t: tVal, y: yVal });
            }
          }
        });
        if (points.length === 0) {
          return 0; // default if parsing fails.
        }
        // Sort points by time.
        points.sort((a, b) => a.t - b.t);
        // Before the first time point:
        if (t <= points[0].t) {
          return points[0].y;
        }
        // After the last time point:
        if (t >= points[points.length - 1].t) {
          return points[points.length - 1].y;
        }
        // Linear interpolation between the surrounding points.
        for (let i = 0; i < points.length - 1; i++) {
          if (t >= points[i].t && t < points[i+1].t) {
            let slope = (points[i+1].y - points[i].y) / (points[i+1].t - points[i].t);
            return points[i].y + slope * (t - points[i].t);
          }
        }
      } else if (refType === "custom") {
        const expr = document.getElementById("refCustomInput").value;
        try {
          // Create a new function f(t) that returns the evaluated expression.
          let f = new Function("t", "return " + expr);
          return f(t);
        } catch (e) {
          console.error("Error evaluating custom reference function:", e);
          return 0;
        }
      }
      return 0;
    }
    
    function simulate() {
      // --- Get system (transfer function) coefficients ---
      let numStr = document.getElementById("numerator").value;
      let denStr = document.getElementById("denominator").value;
      
      // Parse comma–separated coefficients.
      let numCoeffs = numStr.split(",").map(s => parseFloat(s.trim()));
      let denCoeffs = denStr.split(",").map(s => parseFloat(s.trim()));
      
      if (denCoeffs.length < 1 || isNaN(denCoeffs[0]) || denCoeffs[0] === 0) {
        alert("Invalid denominator. The first coefficient must be nonzero.");
        return;
      }
      
      // Normalize so that the leading denominator coefficient is 1.
      let lead = denCoeffs[0];
      denCoeffs = denCoeffs.map(c => c / lead);
      numCoeffs = numCoeffs.map(c => c / lead);
      
      // Let n = degree of denominator, m = degree of numerator.
      let n = denCoeffs.length - 1;
      let m = numCoeffs.length - 1;
      if (m > n) {
        alert("The numerator degree must be less than or equal to the denominator degree.");
        return;
      }
      
      // If the numerator degree is lower than the denominator degree, pad with zeros.
      while (numCoeffs.length < denCoeffs.length) {
        numCoeffs.unshift(0);
      }
      // Now both arrays have length n+1.
      // In controllable canonical form for a transfer function written as:
      //   G(s) = (b₀ sⁿ + b₁ sⁿ⁻¹ + ... + bₙ) / (sⁿ + a₁ sⁿ⁻¹ + ... + aₙ)
      // choose:
      //   D_value = b₀,
      //   C = [b₁ - a₁*D_value, b₂ - a₂*D_value, ..., bₙ - aₙ*D_value],
      //   A = companion matrix built from -a₁, -a₂, ..., -aₙ,
      //   B = [1, 0, ..., 0]ᵀ.
      let D_value = numCoeffs[0];
      let C = [];
      for (let i = 0; i < n; i++) {
        C.push(numCoeffs[i + 1] - denCoeffs[i + 1] * D_value);
      }
      
      // Build the companion matrix A (n x n)
      let A = [];
      for (let i = 0; i < n; i++) {
        A[i] = [];
        for (let j = 0; j < n; j++) {
          if (i === 0) {
            A[i][j] = -denCoeffs[j + 1];
          } else {
            A[i][j] = (j === i - 1) ? 1 : 0;
          }
        }
      }
      
      // B vector is [1, 0, ..., 0]
      let B = new Array(n).fill(0);
      if (n > 0) {
        B[0] = 1;
      }
      
      // --- Get PID and simulation parameters ---
      const Kp = parseFloat(document.getElementById("kp").value);
      const Ki = parseFloat(document.getElementById("ki").value);
      const Kd = parseFloat(document.getElementById("kd").value);
      const N_filter = parseFloat(document.getElementById("N_filter").value);
      const duration = parseFloat(document.getElementById("duration").value);
      const dt = parseFloat(document.getElementById("dt").value);
      const u_max = parseFloat(document.getElementById("u_max").value);
      const u_min = parseFloat(document.getElementById("u_min").value);
      
      // Arrays to store simulation data.
      const timeArr = [];
      const outputArr = [];
      const controlArr = [];
      const setpointArr = [];
      
      // Initial conditions.
      let t = 0;
      // For n > 0, x is the state vector; for n = 0, the system is static.
      let x = (n > 0) ? new Array(n).fill(0) : [];
      let u = 0;
      
      // Compute the initial output.
      let y = (n > 0) ? dotProduct(C, x) + D_value * u : D_value * u;
      let error = getReference(t) - y;
      let integral = 0;
      let previousError = error;
      // d_term holds the state for the filtered derivative.
      let d_term = 0;
      
      // Simulation loop.
      while (t <= duration) {
        // Get the current reference at time t.
        let currentSetpoint = getReference(t);
        // Record time, system output, and reference.
        timeArr.push(t.toFixed(2));
        outputArr.push(y);
        setpointArr.push(currentSetpoint);
        
        // Compute error.
        error = currentSetpoint - y;
        
        // Integral term.
        integral += error * dt;
        
        // Filtered derivative term (Euler integration on: d_dot + N_filter*d = Kd*N_filter*e_dot).
        d_term = (1 - N_filter * dt) * d_term + Kd * N_filter * (error - previousError);
        
        // Controller output.
        let u_new = Kp * error + Ki * integral + d_term;
        // Apply non-symmetric saturation.
        u_new = Math.min(u_max, Math.max(u_min, u_new));
        controlArr.push(u_new);
        
        // Update the system state (Euler integration).
        if (n > 0) {
          let Ax = multiplyMatrixVector(A, x);
          let x_new = [];
          for (let i = 0; i < n; i++) {
            x_new.push(x[i] + dt * (Ax[i] + B[i] * u_new));
          }
          x = x_new;
          y = dotProduct(C, x) + D_value * u_new;
        } else {
          y = D_value * u_new;
        }
        
        previousError = error;
        u = u_new;
        t += dt;
      }
      
      plotData(timeArr, outputArr, setpointArr, controlArr, u_max, u_min);
    }
    
    function plotData(timeArr, outputArr, setpointArr, controlArr, u_max, u_min) {
      const ctx1 = document.getElementById("outputPlot").getContext("2d");
      const ctx2 = document.getElementById("controlPlot").getContext("2d");
      
      if (chartInstance1) chartInstance1.destroy();
      if (chartInstance2) chartInstance2.destroy();
      
      // Plot the system response and reference signal.
      chartInstance1 = new Chart(ctx1, {
        type: 'line',
        data: {
          labels: timeArr,
          datasets: [{
            label: 'System Response',
            data: outputArr,
            borderColor: 'blue',
            borderWidth: 1.5,
            pointRadius: 0,
            fill: false,
          }, {
            label: 'Reference Signal',
            data: setpointArr,
            borderColor: 'red',
            borderWidth: 1,
            pointRadius: 0,
            borderDash: [5, 5],
            fill: false,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            x: { title: { display: true, text: 'Time (s)' } },
            y: { title: { display: true, text: 'Output' } }
          }
        }
      });
      
      // Plot the control signal and its saturation limits.
      chartInstance2 = new Chart(ctx2, {
        type: 'line',
        data: {
          labels: timeArr,
          datasets: [{
            label: 'Control Signal (u)',
            data: controlArr,
            borderColor: 'green',
            borderWidth: 1.5,
            pointRadius: 0,
            fill: false,
          }, {
            label: 'Saturation Upper Limit',
            data: Array(timeArr.length).fill(u_max),
            borderColor: 'black',
            borderWidth: 1,
            pointRadius: 0,
            borderDash: [5, 5],
            fill: false,
          }, {
            label: 'Saturation Lower Limit',
            data: Array(timeArr.length).fill(u_min),
            borderColor: 'black',
            borderWidth: 1,
            pointRadius: 0,
            borderDash: [5, 5],
            fill: false,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            x: { title: { display: true, text: 'Time (s)' } },
            y: { title: { display: true, text: 'Control Signal' } }
          }
        }
      });
    }
  </script>
</body>
</html>
