<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Control Lab</title>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Chart.js Annotation Plugin -->
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2"></script>

<!-- MathJax Configuration (Robust Async) -->
<script>
window.MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
    svg: { fontCache: 'global' },
    startup: {
        ready: () => {
            MathJax.startup.defaultReady();
            window.mathJaxReady = true;
            if (window.updateMath) window.updateMath();
        }
    }
};
</script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Detect if running inside an iframe and add .embedded class -->
<script>
(function () {
    if (window.self !== window.top) {
        document.documentElement.classList.add('embedded');
        document.addEventListener('DOMContentLoaded', function () {
            if (document.body) {
                document.body.classList.add('embedded');
            }
        });
    }
})();
</script>

<style>
:root {
    --primary: #2c3e50;
    --accent: #2980b9;
    --bg: #f4f7f6;
    --panel-bg: #ffffff;
}

* { box-sizing: border-box; }

body {
    font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: var(--bg);
    color: #333;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
/* Plant Sidebar Section (Green Theme) */
.plant-box {
    background-color: #e9f7ef;    /* Light Green Background */
    border: 1px solid #27ae60;    /* Green Border */
    border-radius: 6px;
    padding: 15px;
    margin-bottom: 20px;
}
.plant-box .section-title {
    color: #145a32;               /* Dark Green Text */
    border-bottom-color: #27ae60; /* Green Underline */
}
.plant-box label { color: #145a32; }

/* PID Sidebar Section (Blue Theme) */
.pid-box {
    background-color: #eaf2f8;   /* Light Blue Background */
    border: 1px solid #2980b9;   /* Strong Blue Border */
    border-radius: 6px;
    padding: 15px;
    margin-top: 10px;            
    margin-bottom: 15px;
}
.pid-box label { color: #154360; }
	
/* Feedback Sidebar Section (Purple Theme) */
.feedback-box {
    background-color: #f4ecf7;   /* Light Purple Background */
    border: 1px solid #8e44ad;   /* Strong Purple Border */
    border-radius: 6px;
    padding: 15px;
    margin-bottom: 20px;
}
.feedback-box .section-title {
    color: #5b2c6f;              /* Dark Purple Text */
    border-bottom-color: #8e44ad;/* Purple Underline */
}
.feedback-box label { color: #4a235a; }

.header {
    background: var(--primary);
    color: white;
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    flex-shrink: 0;
    z-index: 100;
}

.header h1 { margin: 0; font-size: 1.2rem; }
.header .status { font-size: 0.8rem; opacity: 0.8; font-family: monospace; }

.main-container { display: flex; flex: 1; overflow: hidden; }

.sidebar {
    width: 360px;
    background: var(--panel-bg);
    border-right: 1px solid #bdc3c7;
    overflow-y: auto;
    padding: 20px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 20px;
    z-index: 20;
}

.content {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.section-title {
    font-size: 1.0rem;
    font-weight: bold;
    color: var(--primary);
    border-bottom: 2px solid var(--accent);
    padding-bottom: 5px;
    margin-bottom: 10px;
    margin-top: 0;
}

.control-group { margin-bottom: 12px; }
.control-group label {
    display: block;
    text-align: left;
    font-size: 0.85rem;
    font-weight: 600;
    color: #555;
    margin-bottom: 4px;
}

.control-group input[type="text"],
.control-group input[type="number"] {
    width: 100%;
    padding: 8px;
    border: 1px solid #bdc3c7;
    border-radius: 4px;
    font-family: monospace;
    font-size: 16px; 
}

.control-group input[type="range"] {
    width: 100%;
    margin-top: 10px;
    cursor: pointer;
    height: 30px;
}

.mode-selector {
    display: flex;
    background: #e0e0e0;
    border-radius: 6px;
    padding: 4px;
    margin-bottom: 15px;
    gap: 4px;
    flex-wrap: wrap;
}

.mode-btn {
    flex: 1;
    text-align: center;
    padding: 10px 4px;
    cursor: pointer;
    border-radius: 4px;
    font-size: 0.85rem;
    font-weight: 600;
    transition: 0.2s;
    white-space: nowrap;
}
.mode-btn.active {
    background: var(--accent);
    color: white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.box {
    background: var(--panel-bg);
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.chart-box { flex: 1; min-height: 350px; position: relative; }

/* Diagram Styles */
.diagram-wrapper {
    position: relative;
    width: 100%;
    height: 200px;
    margin-bottom: 10px;
    overflow-x: auto;
    overflow-y: hidden;
    background: #fff;
    border-radius: 4px;
    border-bottom: 1px solid #eee;
}

.diagram-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 700px;
    height: 100%;
    z-index: 1;
    pointer-events: none;
}

.dia-block {
    position: absolute;
    background: white;
    border: 2px solid #333;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    font-size: 1.0rem;
    font-weight: bold;
}

.dia-sum {
    position: absolute;
    width: 30px;
    height: 30px;
    border: 2px solid #333;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    background: white;
    font-weight: bold;
    font-size: 1.2rem;
    padding-bottom: 3px;
}

/* Specific Block Positions & Color Themes */
#blk-ctrl { 
    left: 150px; top: 35px; width: 100px; height: 60px; 
    background-color: #eaf2f8; border-color: #2980b9; color: #1a5276;
}
#blk-sat { 
    left: 290px; top: 45px; width: 60px;  height: 40px; 
    font-size: 0.85rem;
    background-color: #fff3e0; border-color: #d35400; color: #d35400;
}
#blk-plant { 
    left: 400px; top: 30px; width: 100px; height: 70px; 
    background-color: #e9f7ef; border-color: #27ae60; color: #145a32;
}
#blk-fb { 
    left: 300px; top: 125px; width: 100px; height: 60px; 
    background-color: #f4ecf7; border-color: #8e44ad; color: #5b2c6f;
}

#jct-sum { left: 80px; top: 50px; }

/* Legend / Math Display */
.math-legend {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    padding-top: 10px;
}
.legend-item {
    background: #fdfdfd;
    border: 1px solid #eee;
    padding: 8px;
    border-radius: 4px;
    overflow-x: auto;
    font-size: 0.95rem;
    display: flex;
    align-items: center;
    justify-content: center;
}
.full-width { grid-column: span 2; }

.dia-label {
    position: absolute;
    font-size: 0.85rem;
    font-family: monospace;
    color: #555;
    z-index: 2;
}

.hidden { display: none !important; }
.warn-text { color: #c0392b; font-size: 0.8rem; margin-top: 5px; display: none; }

.sat-box {
    background: #fff3e0;
    padding: 10px;
    border: 1px solid #ffe0b2;
    border-radius: 4px;
    margin-bottom: 15px;
}

.relay-box {
    background: #e8f8f5;
    padding: 10px;
    border: 1px solid #a2d9ce;
    border-radius: 4px;
    margin-bottom: 15px;
}

#mobile-toggle-btn { display: none; }

/* EMBED & MOBILE overrides */
html.embedded, body.embedded { height: auto; min-height: 0; }
body.embedded { overflow: auto; display: block; }
body.embedded .main-container { display: block; height: auto; overflow: visible; }
body.embedded .sidebar, body.embedded .content { overflow: visible; max-height: none; }

@media (max-width: 900px) {
    html, body { height: auto; overflow-y: auto; overflow-x: hidden; -webkit-overflow-scrolling: touch; }
    body { display: block; }
    .header { position: sticky; top: 0; z-index: 100; padding: 12px 15px; }
    .header h1 { font-size: 1.1rem; }
    .header .status { font-size: 0.75rem; }
    .main-container { display: block; height: auto; overflow: visible; }
    .sidebar { width: 100%; border-right: none; border-bottom: 1px solid #ddd; height: auto; overflow: visible; padding: 15px; max-height: none; }
    #mobile-toggle-btn { display: block; width: 100%; padding: 14px; background: #ecf0f1; color: #2c3e50; border: 1px solid #bdc3c7; border-radius: 6px; font-weight: bold; font-size: 0.95rem; margin-bottom: 15px; cursor: pointer; text-align: center; }
    #sidebar-inner { display: none; }
    #sidebar-inner.show { display: block; }
    .content { padding: 15px; height: auto; overflow: visible; padding-bottom: 60px; }
    .chart-box { min-height: 280px; height: 350px; }
    .diagram-wrapper { -webkit-overflow-scrolling: touch; }
    .math-legend { grid-template-columns: 1fr; }
    .full-width { grid-column: span 1; }
    input[type="range"] { height: 40px !important; }
}
</style>
</head>
<body>

<div class="header">
    <h1>Control Lab</h1>
    <div class="status">Dr Ibrahim Kucukdemiral</div>
</div>

<div class="main-container">
    <div class="sidebar">
        <button id="mobile-toggle-btn" type="button" onclick="toggleSidebar()">Show Parameters &#9660;</button>

        <div id="sidebar-inner">
			<div class="plant-box">
                <div class="section-title">Plant Transfer Function G(s)</div>
                <div class="control-group">
                    <label>Numerator Coeffs (descending $s$)</label>
                    <input type="text" id="sys_num" value="10" oninput="updateSystem()">
                </div>
                <div class="control-group">
                    <label>Denominator Coeffs (descending $s$)</label>
                    <input type="text" id="sys_den" value="1, 2, 2, 1" oninput="updateSystem()">
                </div>
                <div class="control-group">
                    <label>Plant Delay ($\tau$) [s]</label>
                    <input type="number" id="sys_delay" value="0.0" step="0.01" min="0" oninput="updateSystem()">
                </div>
                <div id="sys-error" class="warn-text"></div>
            </div>
  
            <!-- Controller -->
            <div>
                <div class="section-title">Controller Strategy C(s)</div>

                <div class="control-group sat-box">
                    <label style="color:#d35400;">Control Limit ($u_{sat}$) [V]</label>
                    <input type="range" id="rng_vLim" min="1" max="100" step="1" value="24"
                           oninput="updateFromSlider('vLim', this.value)">
                    <input type="number" id="num_vLim" value="24"
                           oninput="updateFromBox('vLim', this.value)">
                </div>

                <label style="font-size:0.85rem; font-weight:bold; color:#555; margin-top:10px; display:block; text-align:left;">Control Mode:</label>
                <div class="mode-selector">
                    <div id="btn-pid" class="mode-btn active" onclick="setMode('PID')">PID</div>
                    <div id="btn-relay" class="mode-btn" onclick="setMode('RELAY')">Relay</div>
                    <div id="btn-manual" class="mode-btn" onclick="setMode('MANUAL')">Manual</div>
                    <div id="btn-openloopfr" class="mode-btn" onclick="setMode('OPEN_LOOP_FR')">Open-loop FR</div>
                </div>

                <div class="control-group">
                    <label>Setpoint ($r$)</label>
                    <input type="number" id="setpoint" value="1.0" step="0.1"
                           oninput="updateFromBox('setpoint', this.value)">
                </div>

                <!-- PID controls -->
                <div id="controls-pid" class="pid-box">
                    <div class="control-group">
                        <label>Proportional ($K_p$)</label>
                        <input type="range" id="rng_kp" min="0" max="200" step="0.1" value="1.0"
                               oninput="updateFromSlider('kp', this.value)">
                        <input type="number" id="num_kp" value="1.0" step="0.1"
                               oninput="updateFromBox('kp', this.value)">
                    </div>
                    <div class="control-group">
                        <label>Integral ($K_i$)</label>
                        <input type="range" id="rng_ki" min="0" max="200" step="0.1" value="0.0"
                               oninput="updateFromSlider('ki', this.value)">
                        <input type="number" id="num_ki" value="0.0" step="0.1"
                               oninput="updateFromBox('ki', this.value)">
                    </div>
                    <div class="control-group">
                        <label>Derivative ($K_d$)</label>
                        <input type="range" id="rng_kd" min="0" max="50" step="0.01" value="0.0"
                               oninput="updateFromSlider('kd', this.value)">
                        <input type="number" id="num_kd" value="0.0" step="0.01"
                               oninput="updateFromBox('kd', this.value)">
                    </div>
                    <div class="control-group">
                        <label>Filter Coefficient ($N$)</label>
                        <input type="range" id="rng_N" min="1" max="100" step="1" value="10"
                               oninput="updateFromSlider('N', this.value)">
                        <input type="number" id="num_N" value="10" step="1"
                               oninput="updateFromBox('N', this.value)">
                    </div>
                </div>

                <!-- Relay controls -->
                <div id="controls-relay" class="hidden">
                    <div class="control-group relay-box">
                        <label style="color:#00897b;">Relay Amplitude ($M$)</label>
                        <input type="range" id="rng_relayAmp" min="0.1" max="24" step="0.1" value="5.0"
                               oninput="updateFromSlider('relayAmp', this.value)">
                        <input type="number" id="num_relayAmp" value="5.0" step="0.1"
                               oninput="updateFromBox('relayAmp', this.value)">
                    </div>
                    <div class="control-group relay-box">
                        <label style="color:#00897b;">Hysteresis ($h$)</label>
                        <input type="range" id="rng_hyst" min="0.0" max="2.0" step="0.01" value="0.1"
                               oninput="updateFromSlider('hyst', this.value)">
                        <input type="number" id="num_hyst" value="0.1" step="0.01"
                               oninput="updateFromBox('hyst', this.value)">
                    </div>
                </div>
            </div>

            <!-- Feedback -->
            <div>
                <!-- START: Colored Feedback Box -->
                <div class="feedback-box">
                    <div class="section-title">Feedback Transfer Function H(s)</div>
                    <div class="control-group">
                        <label>Numerator Coeffs (descending $s$)</label>
                        <input type="text" id="fb_num" value="1" oninput="updateFeedback()">
                    </div>
                    <div class="control-group">
                        <label>Denominator Coeffs (descending $s$)</label>
                        <input type="text" id="fb_den" value="1" oninput="updateFeedback()">
                    </div>
                    <div class="control-group">
                        <label>Feedback Delay ($\tau_{fb}$) [s]</label>
                        <input type="number" id="fb_delay" value="0.0" step="0.01" min="0" oninput="updateFeedback()">
                    </div>
                    <div id="fb-error" class="warn-text"></div>
                </div>
                            
                <!-- Time-domain setting -->
                <div class="control-group" id="time-settings" style="margin-top:20px;">
                    <label id="time-label">Simulation Duration [s]</label>
                    <input type="number" id="sim_duration" value="20" step="1" min="1" oninput="updateAll()">
                </div>

                <!-- Frequency-domain settings (shown only in Open-loop FR mode) -->
                <div class="control-group hidden" id="freq-settings" style="margin-top:20px;">
                    <label>Frequency range ω<sub>min</sub> – ω<sub>max</sub> [rad/s]</label>
                    <div style="display:flex; gap:8px;">
                        <input type="number" id="w_min" value="0.01" step="0.01" min="0.0001"
                               oninput="updateBodeCharts()" style="flex:1;">
                        <input type="number" id="w_max" value="100" step="0.1" min="0.001"
                               oninput="updateBodeCharts()" style="flex:1;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="content">
        <!-- Visual Block Diagram -->
        <div class="box">
            <h3 style="margin-top:0; color:var(--primary);">System Block Diagram</h3>
            
            <div class="diagram-wrapper">
                <svg class="diagram-svg" viewBox="0 0 700 200" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <marker id="arrowhead" markerWidth="8" markerHeight="6" 
                        refX="7" refY="3" orient="auto">
                          <polygon points="0 0, 8 3, 0 6" fill="#333" />
                        </marker>
                    </defs>
                    <line x1="20" y1="65" x2="78" y2="65" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <line x1="112" y1="65" x2="148" y2="65" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <line x1="250" y1="65" x2="288" y2="65" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <line x1="350" y1="65" x2="398" y2="65" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <line x1="500" y1="65" x2="650" y2="65" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <line x1="620" y1="65" x2="620" y2="155" stroke="#333" stroke-width="2"/>
                    <line x1="620" y1="155" x2="402" y2="155" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <line x1="300" y1="155" x2="95" y2="155" stroke="#333" stroke-width="2"/>
                    <line x1="95" y1="155" x2="95" y2="82" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <text x="70" y="60" font-family="monospace" font-size="14" fill="#555">+</text>
                    <text x="75" y="110" font-family="monospace" font-size="14" fill="#555">-</text>
                </svg>

                <div class="dia-label" style="left:30px; top:45px;">r(t)</div>
                <div id="jct-sum" class="dia-sum">+</div>
                <div id="blk-ctrl" class="dia-block">$$ G_{PID}(s) $$</div>
                <div id="blk-sat" class="dia-block">Sat</div>
                <div id="blk-plant" class="dia-block">$$ G(s) $$</div>
                <div class="dia-label" style="left:600px; top:45px;">y(t)</div>
                <div id="blk-fb" class="dia-block">$$ H(s) $$</div>
            </div>

            <div class="math-legend">
                <div class="legend-item full-width" id="eq-ctrl"></div>
                <div class="legend-item" id="eq-sat"></div>
                <div class="legend-item" id="eq-plant"></div>
                <div class="legend-item full-width" id="eq-fb"></div>
                <div class="legend-item full-width" id="eq-ol"></div>
            </div>
            
            <div id="filter-explanation"
                 style="margin-top:15px; padding:12px; background:#f8f9fa; border-left:3px solid var(--accent); font-size:0.85rem; line-height:1.5; display:none;">
                <strong>Derivative Filter:</strong> The filtered derivative term prevents amplification of
                high-frequency noise. The transfer function
                <span style="font-family:monospace;">\(D(s) = \frac{K_d \cdot N\,s}{(s+N)}\)</span>
                acts as a first-order high-pass filter where N controls the cutoff frequency.
            </div>
        </div>

        <!-- Info Panel Box -->
        <div class="box" style="padding:12px 16px;">
            <!-- Relay Tuning Info (Default) -->
            <div id="tuner-info"
                 style="background:#eef7ff;border:1px solid #c8ddff;padding:8px 10px;
                        border-radius:6px;font-size:0.85rem;">
                <strong>Relay Auto-Tuning (Åström–Hägglund)</strong><br>
                Period \(P_u\): <span id="tun-Pu">–</span> s |
                Oscillation amplitude \(A_{\text{osc}}\): <span id="tun-A">–</span> |
                \(K_u\): <span id="tun-Ku">–</span>
                <br>
                <span style="margin-right:4px;">Rule:</span>
                <select id="tune-rule" style="font-size:0.8rem;">
                    <option value="P_QDECAY">P, ¼ decay</option>
                    <option value="PI_QDECAY">PI, ¼ decay</option>
                    <option value="PID_QDECAY" selected>PID, ¼ decay</option>
                    <option value="PID_PM30">PID, φ<sub>PM</sub> = 30°</option>
                    <option value="PID_PM45">PID, φ<sub>PM</sub> = 45°</option>
                    <option value="PID_PM60">PID, φ<sub>PM</sub> = 60°</option>
                </select>
                <button id="btn-autotune" disabled
                        onclick="applyAutotunePID()"
                        style="margin-left:8px;padding:4px 8px;font-size:0.8rem;cursor:not-allowed;opacity:0.4;">
                    Apply (auto-tune)
                </button>
                <div style="margin-top:5px;opacity:0.7;">
                    Drag the two vertical bars on the chart to span one period of the relay oscillation.
                </div>
                <div id="tun-formula" style="margin-top:4px;font-size:0.8rem;opacity:0.8;"></div>
            </div>

            <!-- Frequency Response Info Block (Hidden by default, shown in FR mode) -->
            <div id="freq-info" class="hidden"
                 style="background:#fff8e1; border:1px solid #ffecb3; padding:10px;
                        border-radius:6px; font-size:0.9rem; line-height:1.6;">
                <strong style="color:#f57f17;">Frequency Response Margins (Open-Loop)</strong><br>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:5px;">
                    <div>
                        <strong>Gain Crossover</strong> (\(\omega_{gc}\)): <span id="val-wgc" style="font-family:monospace">--</span> rad/s<br>
                        <strong>Phase Margin</strong> (PM): <span id="val-pm" style="font-family:monospace; font-weight:bold;">--</span>&deg;
                    </div>
                    <div>
                        <strong>Phase Crossover</strong> (\(\omega_{pc}\)): <span id="val-wpc" style="font-family:monospace">--</span> rad/s<br>
                        <strong>Gain Margin</strong> (GM): <span id="val-gm" style="font-family:monospace; font-weight:bold;">--</span> dB
                    </div>
                </div>
                <div id="stability-note" style="margin-top:8px; font-style:italic; font-size:0.85rem; color:#555;"></div>
            </div>
        </div>

        <!-- Time-domain chart -->
        <div class="box chart-box" id="time-container">
            <canvas id="simChart"></canvas>
        </div>

        <!-- Bode magnitude -->
        <div class="box chart-box hidden" id="bode-mag-container">
            <h4 style="margin-top:0; color:var(--primary);">Open-loop Magnitude |G(s)H(s)| (dB)</h4>
            <canvas id="bodeMagChart"></canvas>
        </div>

        <!-- Bode phase -->
        <div class="box chart-box hidden" id="bode-phase-container">
            <h4 style="margin-top:0; color:var(--primary);">Open-loop Phase ∠G(s)H(s) (deg)</h4>
            <canvas id="bodePhaseChart"></canvas>
        </div>
    </div>
</div>

<script>
// --- Global state ---
const params = {
    kp: 1.0, ki: 0.0, kd: 0.0, N: 10.0,
    setpoint: 1.0,
    vLim: 24.0,
    relayAmp: 5.0,
    hyst: 0.1
};

// Plant G(s)
let sysA = [], sysB = [], sysC = [], sysD = 0;
let sysOrder = 0;
let sysDelay = 0;
let globalNum = [], globalDen = [], globalDelay = 0;

// Feedback H(s)
let fbA = [], fbB = [], fbC = [], fbD = 1;
let fbOrder = 0;
let fbDelay = 0;
let fbGlobalNum = [], fbGlobalDen = [], fbGlobalDelay = 0;

// Open-loop L(s) = G(s)H(s)
let olNum = [], olDen = [], olDelay = 0;

let controlMode = 'PID';
let chartInstance = null;
let bodeMagChart = null;
let bodePhaseChart = null;

let marker1Index = 50;
let marker2Index = 150;
let draggingMarker = null;
let lastDuration = null;

// --- Layout ---
function toggleSidebar() {
    const content = document.getElementById('sidebar-inner');
    const btn = document.getElementById('mobile-toggle-btn');
    content.classList.toggle('show');
    btn.innerHTML = content.classList.contains('show')
        ? 'Hide Parameters &#9650;'
        : 'Show Parameters &#9660;';
}

function updateAutotuneButton() {
    const btn = document.getElementById('btn-autotune');
    const ruleSelect = document.getElementById('tune-rule');
    if (!btn || !ruleSelect) return;
    const enabled = (controlMode === 'RELAY');
    btn.disabled = !enabled;
    btn.style.opacity = enabled ? '1' : '0.4';
    btn.style.cursor  = enabled ? 'pointer' : 'not-allowed';
    ruleSelect.disabled = !enabled;
}

// --- System Parsing Helper ---
function parseTransferFunction(numId, denId, delayId) {
    const numStr = document.getElementById(numId).value;
    const denStr = document.getElementById(denId).value;
    const delayStr = document.getElementById(delayId).value;
    
    let num = numStr.split(',').map(s => parseFloat(s));
    let den = denStr.split(',').map(s => parseFloat(s));
    let dly = parseFloat(delayStr) || 0;
    
    if (den.some(isNaN) || num.some(isNaN)) throw "Invalid coefficients";
    if (den.length === 0 || den[0] === 0) throw "Invalid denominator";
    
    const a0 = den[0];
    den = den.map(v => v / a0);
    num = num.map(v => v / a0);
    while (num.length < den.length) num.unshift(0);
    
    const order = den.length - 1;
    const D = num[0];
    
    let A = Array(order).fill(0).map(() => Array(order).fill(0));
    let B = Array(order).fill(0);
    let C = Array(order).fill(0);
    
    if (order > 0) {
        for (let i = 0; i < order; i++) {
            A[i][0] = -den[i + 1];
            if (i < order - 1) A[i][i + 1] = 1;
        }
        for (let i = 0; i < order; i++) {
            B[i] = num[i + 1] - den[i + 1] * D;
        }
        C[0] = 1;
    }
    
    let dispNum = [...num];
    while (dispNum.length > 1 && Math.abs(dispNum[0]) < 1e-9) dispNum.shift();
    
    return { A, B, C, D, order, delay: dly, dispNum, den };
}

// Polynomial multiplication for open-loop TF
function polyMultiply(a, b) {
    if (!a || !a.length) return (b && b.length) ? [...b] : [0];
    if (!b || !b.length) return (a && a.length) ? [...a] : [0];
    const res = Array(a.length + b.length - 1).fill(0);
    for (let i = 0; i < a.length; i++) {
        for (let j = 0; j < b.length; j++) {
            res[i + j] += a[i] * b[j];
        }
    }
    return res;
}

function updateOpenLoopTF() {
    const numG = (globalNum && globalNum.length) ? globalNum : [1];
    const denG = (globalDen && globalDen.length) ? globalDen : [1];
    const numH = (fbGlobalNum && fbGlobalNum.length) ? fbGlobalNum : [1];
    const denH = (fbGlobalDen && fbGlobalDen.length) ? fbGlobalDen : [1];

    olNum = polyMultiply(numG, numH);
    olDen = polyMultiply(denG, denH);
    olDelay = (globalDelay || 0) + (fbGlobalDelay || 0);

    if (controlMode === 'OPEN_LOOP_FR') {
        updateBodeCharts();
    }
}

// --- Plant Update ---
function updateSystem() {
    try {
        const sys = parseTransferFunction('sys_num', 'sys_den', 'sys_delay');
        sysA = sys.A; sysB = sys.B; sysC = sys.C; sysD = sys.D;
        sysOrder = sys.order; sysDelay = sys.delay;
        globalNum = sys.dispNum; globalDen = sys.den; globalDelay = sysDelay;
        
        document.getElementById('sys-error').style.display = 'none';
        updateOpenLoopTF();
        renderMath();
        runSimulation();
    } catch (e) {
        document.getElementById('sys-error').innerText = e;
        document.getElementById('sys-error').style.display = 'block';
    }
}

// --- Feedback Update ---
function updateFeedback() {
    try {
        const fb = parseTransferFunction('fb_num', 'fb_den', 'fb_delay');
        fbA = fb.A; fbB = fb.B; fbC = fb.C; fbD = fb.D;
        fbOrder = fb.order; fbDelay = fb.delay;
        fbGlobalNum = fb.dispNum; fbGlobalDen = fb.den; fbGlobalDelay = fbDelay;
        
        document.getElementById('fb-error').style.display = 'none';
        updateOpenLoopTF();
        renderMath();
        runSimulation();
    } catch (e) {
        document.getElementById('fb-error').innerText = e;
        document.getElementById('fb-error').style.display = 'block';
    }
}

// --- UI interactions ---
function setMode(mode) {
    controlMode = mode;
    
    // Explicitly map modes to button IDs to fix Open-loop FR highlight issue
    const btnMap = {
        'PID': 'btn-pid',
        'RELAY': 'btn-relay',
        'MANUAL': 'btn-manual',
        'OPEN_LOOP_FR': 'btn-openloopfr'
    };
    
    for (const [mKey, btnId] of Object.entries(btnMap)) {
        const btn = document.getElementById(btnId);
        if (btn) btn.classList.toggle('active', mKey === mode);
    }
    
    document.getElementById('controls-pid').classList.toggle('hidden', mode !== 'PID');
    document.getElementById('controls-relay').classList.toggle('hidden', mode !== 'RELAY');

    // time vs Bode containers
    const timeCont  = document.getElementById('time-container');
    const magCont   = document.getElementById('bode-mag-container');
    const phaseCont = document.getElementById('bode-phase-container');

    // time vs frequency input visibility
    const timeSettings = document.getElementById('time-settings');
    const freqSettings = document.getElementById('freq-settings');

    // Info Panels (Tuner vs Frequency Info)
    const tunerInfo = document.getElementById('tuner-info');
    const freqInfo  = document.getElementById('freq-info');

    if (mode === 'OPEN_LOOP_FR') {
        // Hide Time Domain, Show Bode
        if (timeCont)  timeCont.classList.add('hidden');
        if (magCont)   magCont.classList.remove('hidden');
        if (phaseCont) phaseCont.classList.remove('hidden');
        if (timeSettings) timeSettings.classList.add('hidden');
        if (freqSettings) freqSettings.classList.remove('hidden');
        
        // Swap Info Panel: Show Frequency Info
        if (tunerInfo) tunerInfo.classList.add('hidden');
        if (freqInfo)  freqInfo.classList.remove('hidden');

        // Update block colors if needed
        const ctrlBlk = document.getElementById('blk-ctrl');
        if (ctrlBlk) {
             ctrlBlk.style.backgroundColor = '#eaf2f8';
             ctrlBlk.style.borderColor = '#2980b9';
             ctrlBlk.style.color = '#1a5276';
        }

        updateBodeCharts();
    } else {
        // Show Time Domain, Hide Bode
        if (timeCont)  timeCont.classList.remove('hidden');
        if (magCont)   magCont.classList.add('hidden');
        if (phaseCont) phaseCont.classList.add('hidden');
        if (timeSettings) timeSettings.classList.remove('hidden');
        if (freqSettings) freqSettings.classList.add('hidden');

        // Swap Info Panel: Show Tuner (or default)
        if (tunerInfo) tunerInfo.classList.remove('hidden');
        if (freqInfo)  freqInfo.classList.add('hidden');

        const ctrlBlk = document.getElementById('blk-ctrl');
        if (ctrlBlk) {
            if (mode === 'RELAY') {
                ctrlBlk.style.backgroundColor = '#e8f8f5';
                ctrlBlk.style.borderColor = '#00897b';
                ctrlBlk.style.color = '#004d40';
            } else {
                ctrlBlk.style.backgroundColor = '#eaf2f8';
                ctrlBlk.style.borderColor = '#2980b9';
                ctrlBlk.style.color = '#1a5276';
            }
        }

        runSimulation();
    }

    if (mode !== 'RELAY') {
        const PuEl = document.getElementById("tun-Pu");
        if (PuEl) PuEl.textContent = '–';
        document.getElementById("tun-A").textContent = '–';
        document.getElementById("tun-Ku").textContent = '–';
        document.getElementById('tun-formula').innerHTML = '';
        window.autoTune = null;
    }

    updateAutotuneButton();
    renderMath();
}


function updateFromSlider(key, val) {
    val = parseFloat(val);
    params[key] = val;
    const num = document.getElementById(`num_${key}`);
    if (num) num.value = val;
    updateAll();
}

function updateFromBox(key, val) {
    const floatVal = parseFloat(val);
    if (isNaN(floatVal)) return;
    params[key] = floatVal;
    const rng = document.getElementById(`rng_${key}`);
    if (rng) rng.value = floatVal;
    updateAll();
}

function updateAll() {
    params.setpoint = parseFloat(document.getElementById('setpoint').value);
    renderMath();
    runSimulation();
    if (controlMode === 'OPEN_LOOP_FR') updateBodeCharts();
}

// --- Math rendering ---
window.updateMath = renderMath;

function renderMath() {
    const poly = (coeffs) => {
        if (!coeffs || coeffs.length === 0) return "0";
        let str = "";
        let ord = coeffs.length - 1;
        coeffs.forEach((c, i) => {
            if (Math.abs(c) < 1e-9) return;
            let p = ord - i;
            let val = parseFloat(Math.abs(c).toFixed(3));
            let sign = (c < 0) ? " - " : " + ";
            if (str === "") sign = (c < 0) ? "-" : "";
            let term = (val === 1 && p > 0) ? "" : `${val}`;
            if (p === 0) str += `${sign}${val}`;
            else if (p === 1) str += `${sign}${term}s`;
            else str += `${sign}${term}s^${p}`;
        });
        return str || "0";
    };
    
    // Plant
    const numText = poly(globalNum);
    const denText = poly(globalDen);
    const delayText = globalDelay > 0 ? `e^{-${globalDelay}s}` : '';
    const sysTex = `$$ G(s) = \\frac{${numText}}{${denText}} ${delayText} $$`;

    // Feedback
    const fbNumText = poly(fbGlobalNum);
    const fbDenText = poly(fbGlobalDen);
    const fbDelayText = fbGlobalDelay > 0 ? `e^{-${fbGlobalDelay}s}` : '';
    const fbTex = `$$ H(s) = \\frac{${fbNumText}}{${fbDenText}} ${fbDelayText} $$`;

    // Open-loop L(s)
    const olNumText = poly(olNum);
    const olDenText = poly(olDen);
    const olDelayText = olDelay > 0 ? `e^{-${olDelay}s}` : '';
    const olTex = `$$ L(s) = G(s)H(s) = \\frac{${olNumText}}{${olDenText}} ${olDelayText} $$`;

    // Controller text
    let ctrlTex = "";
    if (controlMode === 'PID') {
        const kp = params.kp.toFixed(2);
        const ki = params.ki.toFixed(2);
        const kd = params.kd.toFixed(2);
        const N  = params.N.toFixed(0);
        ctrlTex = `$$ G_{PID}(s) = ${kp} + \\frac{${ki}}{s} + \\frac{${kd} \\cdot ${N} s}{s + ${N}} $$`;
    } else if (controlMode === 'RELAY') {
        ctrlTex = `$$ \\text{Relay: } u(t) = \\text{sgn}(e) \\cdot ${params.relayAmp} \\quad (\\text{hyst}=${params.hyst}) $$`;
    } else if (controlMode === 'MANUAL') {
        ctrlTex = `$$ \\text{Manual Mode: } u(t) = r(t) $$`;
    } else if (controlMode === 'OPEN_LOOP_FR') {
        ctrlTex = `$$ \\text{Open-loop FR mode (PID ignored).} $$`;
    }
    
    const satTex = `$$ \\text{Sat: } \\pm ${params.vLim} \\text{ V} $$`;
    
    const eqCtrl = document.getElementById('eq-ctrl');
    const eqSat  = document.getElementById('eq-sat');
    const eqPlant= document.getElementById('eq-plant');
    const eqFb   = document.getElementById('eq-fb');
    const eqOL   = document.getElementById('eq-ol');
    
    if (eqCtrl) eqCtrl.innerHTML  = ctrlTex;
    if (eqSat)  eqSat.innerHTML   = satTex;
    if (eqPlant)eqPlant.innerHTML = sysTex;
    if (eqFb)   eqFb.innerHTML    = fbTex;
    if (eqOL)   eqOL.innerHTML    = olTex;

    const blkCtrl = document.getElementById('blk-ctrl');
    if (blkCtrl && controlMode === 'PID')  blkCtrl.innerHTML = `$$ G_{PID}(s) $$`;
    if (blkCtrl && controlMode === 'RELAY')blkCtrl.innerHTML = `$$ \\text{Relay} $$`;
    if (blkCtrl && controlMode === 'MANUAL')blkCtrl.innerHTML= `$$ \\text{Man} $$`;
    if (blkCtrl && controlMode === 'OPEN_LOOP_FR') blkCtrl.innerHTML = `$$ G_{PID}(s) $$`;

    const explDiv = document.getElementById('filter-explanation');
    if (explDiv) {
        explDiv.style.display = (controlMode === 'PID' && params.kd > 0) ? 'block' : 'none';
    }
    
    if (window.MathJax && MathJax.typesetPromise) {
        const wrapper = document.querySelector('.box');
        MathJax.typesetPromise([wrapper]).catch(e => console.log('Math error', e));
    }
}

// --- Frequency response of L(s) = G(s)H(s) ---
function evalPoly(coeffs, s) {
    let res = { re: 0, im: 0 };
    for (let i = 0; i < coeffs.length; i++) {
        const c = coeffs[i];
        const power = coeffs.length - 1 - i;
        let sp = { re: 1, im: 0 };
        if (power > 0) {
            sp = { re: 0, im: 1 };
            let acc = { re: 1, im: 0 };
            for (let k = 0; k < power; k++) {
                const tmp = {
                    re: acc.re * sp.re - acc.im * sp.im,
                    im: acc.re * sp.im + acc.im * sp.re
                };
                acc = tmp;
            }
            sp = acc;
        }
        res.re += c * sp.re;
        res.im += c * sp.im;
    }
    return res;
}

function evalPolyAtJW(coeffs, w) {
    const s = { re: 0, im: w };
    let res = { re: 0, im: 0 };
    for (let i = 0; i < coeffs.length; i++) {
        const tmp = {
            re: res.re * s.re - res.im * s.im,
            im: res.re * s.im + res.im * s.re
        };
        res.re = tmp.re + coeffs[i];
        res.im = tmp.im;
    }
    return res;
}

function complexDiv(a, b) {
    const den = b.re * b.re + b.im * b.im;
    return {
        re: (a.re * b.re + a.im * b.im) / den,
        im: (a.im * b.re - a.re * b.im) / den
    };
}


function updateBodeCharts() {
    if (!olNum || !olNum.length || !olDen || !olDen.length) return;

    const N = 500; // INCREASED RESOLUTION FOR SMOOTHER PLOTS

    const wMinInput = document.getElementById("w_min");
    const wMaxInput = document.getElementById("w_max");
    let wMin = wMinInput ? parseFloat(wMinInput.value) : 0.01;
    let wMax = wMaxInput ? parseFloat(wMaxInput.value) : 100;

    if (!isFinite(wMin) || wMin <= 0) wMin = 0.01;
    if (!isFinite(wMax) || wMax <= wMin) wMax = wMin * 10;

    const logMin = Math.log10(wMin);
    const logMax = Math.log10(wMax);

    const wList = [];
    const magDB = [];
    const phaseDeg = [];

    // --- CONTINUOUS PHASE CALCULATION ---
    // Instead of calculating absolute phase at every point and unwrapping,
    // we accumulate the angle change (delta) between steps.
    // This avoids jumps completely.

    let prevL = null; // Store previous complex value
    let accumulatedPhase = 0;

    for (let i = 0; i < N; i++) {
        const exp = logMin + (logMax - logMin) * i / (N - 1);
        const w = Math.pow(10, exp);

        // Calculate L(jw)
        const nVal = evalPolyAtJW(olNum, w);
        const dVal = evalPolyAtJW(olDen, w);
        const L = complexDiv(nVal, dVal);

        // Apply Delay
        let Ld = L;
        if (olDelay && olDelay > 0) {
            const phi = -w * olDelay;
            const c = Math.cos(phi);
            const s = Math.sin(phi);
            Ld = {
                re: L.re * c - L.im * s,
                im: L.re * s + L.im * c
            };
        }

        const mag = Math.sqrt(Ld.re * Ld.re + Ld.im * Ld.im);
        const mag_dB = 20 * Math.log10(mag);

        // Phase Calculation
        if (i === 0) {
            // Initial phase (using standard atan2)
            accumulatedPhase = Math.atan2(Ld.im, Ld.re) * 180 / Math.PI;
        } else {
            // Calculate delta angle from previous point
            // Angle(z2/z1) = Angle(z2 * conj(z1))
            // Let z2 = Ld (current), z1 = prevL (previous)
            // z2 * z1* = (a+bi)(c-di) = (ac+bd) + i(bc-ad)
            const ac_bd = Ld.re * prevL.re + Ld.im * prevL.im;
            const bc_ad = Ld.im * prevL.re - Ld.re * prevL.im;
            
            const delta = Math.atan2(bc_ad, ac_bd) * 180 / Math.PI;
            accumulatedPhase += delta;
        }

        prevL = Ld; // Store for next step

        wList.push(w);
        magDB.push(mag_dB);
        phaseDeg.push(accumulatedPhase);
    }

    // --- MARGIN CALCULATION LOGIC ---
    let wc_gain = null; // Gain Crossover Freq (Mag = 0 dB)
    let wc_phase = null; // Phase Crossover Freq (Phase = -180 deg)
    let pm = null;       // Phase Margin
    let gm = null;       // Gain Margin

    // A. Find Gain Crossover (where Magnitude crosses 0 dB)
    for (let i = 0; i < N - 1; i++) {
        if ((magDB[i] >= 0 && magDB[i+1] < 0) || (magDB[i] <= 0 && magDB[i+1] > 0)) {
            // Linear interpolate w
            const m1 = magDB[i], m2 = magDB[i+1];
            const w1 = wList[i], w2 = wList[i+1];
            const slope = (m2 - m1) / (w2 - w1);
            wc_gain = w1 - (m1 / slope);
            
            // Get Phase at this freq (interpolate)
            // Linear interpolation of phase is safe here due to high resolution
            const p1 = phaseDeg[i], p2 = phaseDeg[i+1];
            const p_at_wc = p1 + (p2 - p1) * (wc_gain - w1) / (w2 - w1);
            
            // Normalize phase to find distance from -180
            // PM = 180 + Phase(Wgc)
            // Need to unwrap relative to -180
            let p_norm = p_at_wc;
            while(p_norm > 0) p_norm -= 360;
            while(p_norm <= -360) p_norm += 360;
            
            pm = 180 + p_norm;
            break; 
        }
    }

    // B. Find Phase Crossover (where Phase crosses -180, -540, etc)
    for (let i = 0; i < N - 1; i++) {
        // Check crossing of any odd multiple of 180 (e.g., -180, -540)
        // Normalize checking logic:
        // We look for crossing of -180 relative to 360 mod.
        let p1 = phaseDeg[i];
        let p2 = phaseDeg[i+1];
        
        // Normalize to -360..0 for detection
        let p1_n = p1; while(p1_n > 0) p1_n -= 360; while(p1_n <= -360) p1_n += 360;
        let p2_n = p2; while(p2_n > 0) p2_n -= 360; while(p2_n <= -360) p2_n += 360;

        if ((p1_n >= -180 && p2_n < -180) || (p1_n <= -180 && p2_n > -180)) {
             const w1 = wList[i], w2 = wList[i+1];
             // Interpolate w based on the normalized phase crossing -180
             const slope = (p2_n - p1_n) / (w2 - w1);
             wc_phase = w1 - ((p1_n + 180) / slope);

             // Calculate Exact Gain at this frequency
             const nVal = evalPolyAtJW(olNum, wc_phase);
             const dVal = evalPolyAtJW(olDen, wc_phase);
             let L = complexDiv(nVal, dVal);
             const mag = Math.sqrt(L.re*L.re + L.im*L.im);
             const mag_db = 20*Math.log10(mag);
             
             gm = -mag_db; 
             break;
        }
    }

    // 3. Update HTML Info Panel
    const elWgc = document.getElementById("val-wgc");
    const elPm  = document.getElementById("val-pm");
    const elWpc = document.getElementById("val-wpc");
    const elGm  = document.getElementById("val-gm");
    const elNote= document.getElementById("stability-note");

    if (elWgc) elWgc.innerText = (wc_gain !== null) ? wc_gain.toFixed(3) : "∞";
    if (elPm)  elPm.innerText  = (pm !== null) ? pm.toFixed(1) : "--";
    if (elWpc) elWpc.innerText = (wc_phase !== null) ? wc_phase.toFixed(3) : "∞";
    if (elGm)  elGm.innerText  = (gm !== null) ? gm.toFixed(1) : "--";

    if (elNote) {
        if (pm !== null && gm !== null) {
            if (pm > 0 && gm > 0) {
                elNote.innerText = "System appears Stable (PM > 0, GM > 0)";
                elNote.style.color = "#27ae60";
            } else {
                elNote.innerText = "System appears Unstable";
                elNote.style.color = "#c0392b";
            }
        } else {
             elNote.innerText = "";
        }
    }

    // 4. Plot Charts
    const magCtx   = document.getElementById('bodeMagChart').getContext('2d');
    const phaseCtx = document.getElementById('bodePhaseChart').getContext('2d');

    const xScaleConfig = {
        type: 'logarithmic',
        title: { display: true, text: 'Frequency ω (rad/s)' },
        ticks: {
            callback: function(value) { return value; }
        }
    };

    if (!bodeMagChart) {
        bodeMagChart = new Chart(magCtx, {
            type: 'line',
            data: {
                labels: wList,
                datasets: [{
                    label: '|G(s)H(s)| (dB)',
                    data: magDB,
                    borderColor: '#2980b9',
                    borderWidth: 2,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    x: xScaleConfig,
                    y: {
                        title: { display: true, text: 'Magnitude (dB)' }
                    }
                }
            }
        });
    } else {
        bodeMagChart.data.labels = wList;
        bodeMagChart.data.datasets[0].data = magDB;
        bodeMagChart.update('none');
    }

    if (!bodePhaseChart) {
        bodePhaseChart = new Chart(phaseCtx, {
            type: 'line',
            data: {
                labels: wList,
                datasets: [{
                    label: '∠G(s)H(s) (deg)',
                    data: phaseDeg,
                    borderColor: '#8e44ad',
                    borderWidth: 2,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    x: xScaleConfig,
                    y: {
                        title: { display: true, text: 'Phase (deg)' }
                    }
                }
            }
        });
    } else {
        bodePhaseChart.data.labels = wList;
        bodePhaseChart.data.datasets[0].data = phaseDeg;
        bodePhaseChart.update('none');
    }
}

// --- Generic RK4 Solver ---
function getDerivatives(A, B, x, u, order) {
    let dx = new Array(order).fill(0);
    for (let i = 0; i < order; i++) {
        let Ax_i = 0;
        for (let j = 0; j < order; j++) Ax_i += A[i][j] * x[j];
        dx[i] = Ax_i + B[i] * u;
    }
    return dx;
}

function rk4Step(A, B, x, u, dt, order) {
    if (order === 0) return [];
    let k1 = getDerivatives(A, B, x, u, order);
    let x2 = x.map((val, i) => val + 0.5 * dt * k1[i]);
    let k2 = getDerivatives(A, B, x2, u, order);
    let x3 = x.map((val, i) => val + 0.5 * dt * k2[i]);
    let k3 = getDerivatives(A, B, x3, u, order);
    let x4 = x.map((val, i) => val + dt * k3[i]);
    let k4 = getDerivatives(A, B, x4, u, order);
    return x.map((val, i) => val + (dt/6.0) * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i]));
}

// --- Simulation Loop ---
function runSimulation() {
    if (controlMode === 'OPEN_LOOP_FR') {
        // No need to update time-domain when only looking at Bode
        return;
    }

    const durInput = document.getElementById('sim_duration');
    const duration = durInput ? (parseFloat(durInput.value) || 20.0) : 20.0;
    
    const resetMarkers = (lastDuration === null || Math.abs(duration - lastDuration) > 1e-9);
    lastDuration = duration;
    
    const dt = 0.001;
    const steps = Math.floor(duration / dt);
    
    // Plant State
    let xSys = new Array(sysOrder).fill(0);
    let sysDelaySteps = Math.floor(sysDelay / dt);
    let uBuffer = new Array(Math.max(sysDelaySteps, 0) + 1).fill(0);
    let uPrev = 0;

    // Feedback State
    let xFb = new Array(fbOrder).fill(0);
    let fbDelaySteps = Math.floor(fbDelay / dt);
    let yBuffer = new Array(Math.max(fbDelaySteps, 0) + 1).fill(0);

    // Controller State
    let integral = 0, prevError = 0, ud_prev = 0, time = 0;
    let relayState = 0;
    
    const tData = [], yData = [], rData = [], uData = [], fbData = [];
    const satMax = Math.abs(params.vLim);
    
    for (let k = 0; k <= steps; k++) {
        // Plant output
        let u_for_sys_out = (sysDelaySteps > 0 && uBuffer.length > 0) ? uBuffer[0] : uPrev;
        
        let y_val = sysD * u_for_sys_out;
        if (sysOrder > 0) {
            y_val += sysC.reduce((sum, v, i) => sum + v * xSys[i], 0);
        }

        // Feedback
        if (fbDelaySteps > 0) {
            yBuffer.push(y_val);
            yBuffer.shift();
        } else {
            yBuffer[0] = y_val;
        }
        
        let y_in_fb = (fbDelaySteps > 0) ? yBuffer[0] : y_val; 
        
        let y_meas = fbD * y_in_fb;
        if (fbOrder > 0) {
            y_meas += fbC.reduce((sum, v, i) => sum + v * xFb[i], 0);
        }

        const r = params.setpoint;
        const e = r - y_meas;
        let u = 0;
        
        if (controlMode === 'PID') {
            const P = params.kp * e;
            integral += e * dt;
            if (Math.abs(integral * params.ki) > satMax)
                integral = (satMax / (params.ki || 1e-9)) * Math.sign(integral);
            const I = params.ki * integral;
            const N = params.N;
            const diff = e - prevError;
            const ud = (ud_prev + N * params.kd * diff) / (1 + N * dt);
            ud_prev = ud;
            u = P + I + ud;
        } else if (controlMode === 'RELAY') {
            const h = params.hyst;
            if (relayState === 0) relayState = (e > 0) ? 1 : -1;
            if (e > h) relayState = 1;
            else if (e < -h) relayState = -1;
            u = relayState * params.relayAmp;
            integral = 0;
            ud_prev = 0;
        } else { // MANUAL
            u = r;
            integral = 0;
            ud_prev = 0;
        }
        prevError = e;
        
        // Saturation
        if (u > satMax) u = satMax;
        if (u < -satMax) u = -satMax;
        
        // Delay into plant
        let u_plant_in;
        if (sysDelaySteps > 0) {
            uBuffer.push(u);
            uBuffer.shift();
            u_plant_in = uBuffer[0];
        } else {
            u_plant_in = u;
        }
        
        if (sysOrder > 0) xSys = rk4Step(sysA, sysB, xSys, u_plant_in, dt, sysOrder);
        if (fbOrder > 0)  xFb  = rk4Step(fbA, fbB, xFb, y_in_fb, dt, fbOrder);
        
        const downsample = Math.ceil(steps / 600);
        if (k % downsample === 0 || k === steps) {
            tData.push(time);
            yData.push(y_val);
            fbData.push(y_meas);
            rData.push(controlMode !== 'MANUAL' ? r : 0);
            uData.push(u);
        }
        
        time += dt;
        uPrev = u;
    }
    
    drawChart(tData, yData, rData, uData, fbData, resetMarkers);
}

// --- Chart + marker plugin ---
const markerPlugin = {
    id: 'markerPlugin',
    afterDraw(chart) {
        if (controlMode !== 'RELAY') return; // only show markers in relay mode
        const ctx = chart.ctx;
        const xScale = chart.scales.x;
        const labels = chart.data.labels || [];
        if (!labels.length) return;
        
        [marker1Index, marker2Index].forEach((idx, i) => {
            if (idx < 0 || idx >= labels.length) return;
            const x = xScale.getPixelForValue(labels[idx]);
            ctx.save();
            ctx.strokeStyle = i === 0 ? '#e74c3c' : '#000000'; // red & black
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, chart.chartArea.top);
            ctx.lineTo(x, chart.chartArea.bottom);
            ctx.stroke();
            ctx.restore();
        });
    }
};

Chart.register(markerPlugin);

function drawChart(labels, yData, rData, uData, fbData, resetMarkers) {
    if (typeof Chart === 'undefined') return;
    const ctx = document.getElementById('simChart').getContext('2d');
    const showRef = (controlMode !== 'MANUAL');
    
    if (!chartInstance) {
        chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,   
                datasets: [
                    {
                        label: 'Plant Output (y)',
                        data: yData,
                        borderColor: '#2980b9',
                        borderWidth: 2,
                        pointRadius: 0,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Setpoint (r)',
                        data: rData,
                        borderColor: '#e74c3c',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        yAxisID: 'y',
                        hidden: !showRef
                    },
                    {
                        label: 'Measured Feedback',
                        data: fbData,
                        borderColor: '#8e44ad',
                        borderWidth: 1,
                        borderDash: [2, 2],
                        pointRadius: 0,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Control (u)',
                        data: uData,
                        borderColor: '#27ae60',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: true,
                        backgroundColor: 'rgba(39,174,96,0.1)',
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: {mode: 'index', intersect: false},
                scales: {
                    x: {
                        type: 'linear',
                        title: {display: true, text: 'Time (s)'},
                        ticks: {maxTicksLimit: 8}
                    },
                    y: {
                        position: 'left',
                        title: {display: true, text: 'Output'}
                    },
                    y1: {
                        position: 'right',
                        title: {display: true, text: 'Control'},
                        grid: {drawOnChartArea: false}
                    }
                }
            }
        });
        attachMarkerEvents();
    } else {
        chartInstance.data.labels = labels;
        chartInstance.data.datasets[0].data = yData;
        chartInstance.data.datasets[1].data = rData;
        chartInstance.data.datasets[1].hidden = !showRef;
        chartInstance.data.datasets[2].data = fbData;
        chartInstance.data.datasets[3].data = uData;
    }
    
    if (labels.length > 2) {
        if (resetMarkers) {
            const n = labels.length;
            marker1Index = Math.floor(n / 3);
            marker2Index = Math.floor(2 * n / 3);
        } else {
            marker1Index = Math.min(marker1Index, labels.length - 2);
            marker2Index = Math.min(marker2Index, labels.length - 1);
        }
    }
    
    chartInstance.update('none');
    updateAutoTune();
}

function attachMarkerEvents() {
    const canvas = document.getElementById('simChart');
    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('mousemove', dragMove);
    document.addEventListener('mouseup', endDrag);
    
    canvas.addEventListener('touchstart', startDrag, {passive: false});
    canvas.addEventListener('touchmove', dragMove, {passive: false});
    document.addEventListener('touchend', endDrag);
}

function getMouseX(evt) {
    const rect = chartInstance.canvas.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    return clientX - rect.left;
}

function closestIndexFromPixel(xPixel) {
    const labels = chartInstance.data.labels || [];
    const xScale = chartInstance.scales.x;
    if (!labels.length) return 0;
    
    const value = xScale.getValueForPixel(xPixel);
    let bestIdx = 0;
    let bestDist = Infinity;
    for (let i = 0; i < labels.length; i++) {
        const d = Math.abs(labels[i] - value);
        if (d < bestDist) {
            bestDist = d;
            bestIdx = i;
        }
    }
    return bestIdx;
}

function startDrag(evt) {
    if (controlMode !== 'RELAY') return;
    if (!chartInstance) return;
    const xScale = chartInstance.scales.x;
    const labels = chartInstance.data.labels || [];
    if (!labels.length) return;
    
    const x = getMouseX(evt);
    const m1x = xScale.getPixelForValue(labels[marker1Index]);
    const m2x = xScale.getPixelForValue(labels[marker2Index]);
    
    if (Math.abs(x - m1x) < 12) draggingMarker = 1;
    else if (Math.abs(x - m2x) < 12) draggingMarker = 2;
}

function dragMove(evt) {
    if (!draggingMarker || !chartInstance) return;
    evt.preventDefault();
    const x = getMouseX(evt);
    const idx = closestIndexFromPixel(x);
    
    if (draggingMarker === 1) marker1Index = idx;
    else if (draggingMarker === 2) marker2Index = idx;
    
    chartInstance.update('none');
    updateAutoTune();
}

function endDrag() { draggingMarker = null; }

// --- Auto-tune ---
function updateAutoTune() {
    if (controlMode !== 'RELAY') return;
    if (!chartInstance) return;
    const labels = chartInstance.data.labels || [];
    if (!labels.length) return;
    
    const y = chartInstance.data.datasets[2].data || [];
    
    let i1 = Math.min(marker1Index, marker2Index);
    let i2 = Math.max(marker1Index, marker2Index);
    if (i1 < 0) i1 = 0;
    if (i2 >= labels.length) i2 = labels.length - 1;
    if (i2 <= i1) return;
    
    const t1 = labels[i1];
    const t2 = labels[i2];
    if (!isFinite(t1) || !isFinite(t2)) return;
    
    const Pu = Math.abs(t2 - t1);
    const windowY = y.slice(i1, i2 + 1);
    if (!windowY.length) return;
    
    const ymin = Math.min(...windowY);
    const ymax = Math.max(...windowY);
    const Aosc = (ymax - ymin) / 2;
    if (Aosc <= 0) return;
    
    const M = params.relayAmp;
    const h = Math.abs(params.hyst || 0);

    let Ku;
    const useHyst = (h > 0 && h < Aosc);
    if (useHyst) {
        const ratio = h / Aosc;
        const corr  = Math.sqrt(1 - ratio * ratio);
        Ku = (Math.PI * Aosc) / (4 * M * corr);
    } else {
        Ku = 4 * M / (Math.PI * Aosc);
    }
    
    document.getElementById("tun-Pu").textContent = Pu.toFixed(3);
    document.getElementById("tun-A").textContent = Aosc.toFixed(3);
    document.getElementById("tun-Ku").textContent = Ku.toFixed(3);
    
    window.autoTune = {Pu, Aosc, Ku};

    const formulaDiv = document.getElementById('tun-formula');
    if (formulaDiv) {
        if (useHyst) {
            formulaDiv.innerHTML = '\\(K_u = \\dfrac{\\pi A}{4 M \\sqrt{1 - (h/A)^2}}\\)';
        } else {
            formulaDiv.innerHTML = '\\(K_u = \\dfrac{4 M}{\\pi A}\\)';
        }
        if (window.MathJax && MathJax.typesetPromise) {
            MathJax.typesetPromise([formulaDiv]).catch(e => console.log('Math error', e));
        }
    }
}

function applyAutotunePID() {
    if (controlMode !== 'RELAY' || !window.autoTune) return;

    const {Pu, Ku} = window.autoTune;
    const rule = document.getElementById("tune-rule").value;
    
    let Kp, Ti, Td;
    switch (rule) {
        case 'P_QDECAY':   Kp = 0.5 * Ku;  Ti = 0;          Td = 0;           break;
        case 'PI_QDECAY':  Kp = 0.45 * Ku; Ti = 0.833 * Pu; Td = 0;           break;
        case 'PID_QDECAY': Kp = 0.6 * Ku;  Ti = 0.5 * Pu;   Td = 0.125 * Pu;  break;
        case 'PID_PM30':   Kp = 0.87 * Ku; Ti = 0.55 * Pu;  Td = 0.14 * Pu;   break;
        case 'PID_PM45':   Kp = 0.71 * Ku; Ti = 0.77 * Pu;  Td = 0.20 * Pu;   break;
        case 'PID_PM60':   Kp = 0.50 * Ku; Ti = 1.29 * Pu;  Td = 0.30 * Pu;   break;
        default:           Kp = 0.6 * Ku;  Ti = 0.5 * Pu;   Td = 0.125 * Pu;
    }
    
    const Ki = (Ti > 0) ? Kp / Ti : 0;
    const Kd = Kp * Td;
    
    params.kp = Kp;
    params.ki = Ki;
    params.kd = Kd;
    
    document.getElementById("num_kp").value = Kp.toFixed(3);
    document.getElementById("num_ki").value = Ki.toFixed(3);
    document.getElementById("num_kd").value = Kd.toFixed(3);
    
    const rng_kp = document.getElementById("rng_kp");
    const rng_ki = document.getElementById("rng_ki");
    const rng_kd = document.getElementById("rng_kd");
    if (rng_kp) rng_kp.value = Math.min(Kp, parseFloat(rng_kp.max));
    if (rng_ki) rng_ki.value = Math.min(Ki, parseFloat(rng_ki.max));
    if (rng_kd) rng_kd.value = Math.min(Kd, parseFloat(rng_kd.max));
    
    setMode("PID");
    updateAll();
}

// --- Init ---
window.onload = function () {
    updateSystem();
    updateFeedback();
    updateAutotuneButton();
};
</script>
</body>
</html>
